   1              		.cpu cortex-m0
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 6
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f0_hal_lowlevel.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.HAL_GetTick,"ax",%progbits
  16              		.align	1
  17              		.global	HAL_GetTick
  18              		.arch armv6s-m
  19              		.syntax unified
  20              		.code	16
  21              		.thumb_func
  22              		.fpu softvfp
  24              	HAL_GetTick:
  25              	.LFB37:
  26              		.file 1 ".././hal/stm32f0/stm32f0_hal_lowlevel.c"
   1:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /* This file combines several STM32F4 HAL Functions into one file. This was done
   2:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    for space reasons, to avoid having several MB of HAL functions that most people
   3:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    will not use. In addition this HAL is slightly less demanding (no interrupts),
   4:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    but less robust as doesn't implement the timeouts.
   5:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    
   6:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    The original HAL files are COPYRIGHT STMicroelectronics, as shown below:
   7:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** */
   8:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
   9:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /*
  10:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * COPYRIGHT(c) 2017 STMicroelectronics
  11:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  12:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * Redistribution and use in source and binary forms, with or without modification,
  13:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * are permitted provided that the following conditions are met:
  14:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   1. Redistributions of source code must retain the above copyright notice,
  15:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      this list of conditions and the following disclaimer.
  16:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   2. Redistributions in binary form must reproduce the above copyright notice,
  17:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      this list of conditions and the following disclaimer in the documentation
  18:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      and/or other materials provided with the distribution.
  19:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *   3. Neither the name of STMicroelectronics nor the names of its contributors
  20:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      may be used to endorse or promote products derived from this software
  21:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *      without specific prior written permission.
  22:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  23:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  24:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  25:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  27:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  28:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  29:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  30:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  31:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  32:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
  34:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   ******************************************************************************
  35:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** */ 
  36:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  37:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  38:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0_hal.h"
  39:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0_hal_lowlevel.h"
  40:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_rcc.h"
  41:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_gpio.h"
  42:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_dma.h"
  43:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_uart.h"
  44:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #include "stm32f0xx_hal_flash.h"
  45:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  46:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define assert_param(expr) ((void)0U)
  47:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  48:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_GetTick(void)
  49:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
  27              		.loc 1 49 1
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31 0000 80B5     		push	{r7, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  36 0002 00AF     		add	r7, sp, #0
  37              	.LCFI1:
  38              		.cfi_def_cfa_register 7
  50:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	static uint32_t tick;
  51:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return tick++;;
  39              		.loc 1 51 13
  40 0004 044B     		ldr	r3, .L3
  41 0006 1A68     		ldr	r2, [r3]
  42 0008 511C     		adds	r1, r2, #1
  43 000a 034B     		ldr	r3, .L3
  44 000c 1960     		str	r1, [r3]
  45 000e 1300     		movs	r3, r2
  52:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
  46              		.loc 1 52 1
  47 0010 1800     		movs	r0, r3
  48 0012 BD46     		mov	sp, r7
  49              		@ sp needed
  50 0014 80BD     		pop	{r7, pc}
  51              	.L4:
  52 0016 C046     		.align	2
  53              	.L3:
  54 0018 00000000 		.word	tick.0
  55              		.cfi_endproc
  56              	.LFE37:
  58              		.global	SystemCoreClock
  59              		.data
  60              		.align	2
  63              	SystemCoreClock:
  64 0000 00127A00 		.word	8000000
  65              		.section	.text.HAL_RCC_GetSysClockFreq,"ax",%progbits
  66              		.align	1
  67              		.global	HAL_RCC_GetSysClockFreq
  68              		.syntax unified
  69              		.code	16
  70              		.thumb_func
  71              		.fpu softvfp
  73              	HAL_RCC_GetSysClockFreq:
  74              	.LFB38:
  53:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  54:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define UART_CR1_FIELDS  ((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | \
  55:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                      USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8)) /*!< UART or U
  56:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 									 
  57:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t SystemCoreClock = 8000000;
  58:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  59:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  60:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetSysClockFreq(void)
  61:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
  75              		.loc 1 61 1
  76              		.cfi_startproc
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 1, uses_anonymous_args = 0
  79 0000 80B5     		push	{r7, lr}
  80              	.LCFI2:
  81              		.cfi_def_cfa_offset 8
  82              		.cfi_offset 7, -8
  83              		.cfi_offset 14, -4
  84 0002 00AF     		add	r7, sp, #0
  85              	.LCFI3:
  86              		.cfi_def_cfa_register 7
  62:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return 7372800U;
  87              		.loc 1 62 9
  88 0004 E123     		movs	r3, #225
  89 0006 DB03     		lsls	r3, r3, #15
  63:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
  90              		.loc 1 63 1
  91 0008 1800     		movs	r0, r3
  92 000a BD46     		mov	sp, r7
  93              		@ sp needed
  94 000c 80BD     		pop	{r7, pc}
  95              		.cfi_endproc
  96              	.LFE38:
  98              		.section	.text.HAL_RCC_GetPCLK1Freq,"ax",%progbits
  99              		.align	1
 100              		.global	HAL_RCC_GetPCLK1Freq
 101              		.syntax unified
 102              		.code	16
 103              		.thumb_func
 104              		.fpu softvfp
 106              	HAL_RCC_GetPCLK1Freq:
 107              	.LFB39:
  64:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  65:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetPCLK1Freq(void)
  66:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 108              		.loc 1 66 1
 109              		.cfi_startproc
 110              		@ args = 0, pretend = 0, frame = 0
 111              		@ frame_needed = 1, uses_anonymous_args = 0
 112 0000 80B5     		push	{r7, lr}
 113              	.LCFI4:
 114              		.cfi_def_cfa_offset 8
 115              		.cfi_offset 7, -8
 116              		.cfi_offset 14, -4
 117 0002 00AF     		add	r7, sp, #0
 118              	.LCFI5:
 119              		.cfi_def_cfa_register 7
  67:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 	return 7372800U;
 120              		.loc 1 67 9
 121 0004 E123     		movs	r3, #225
 122 0006 DB03     		lsls	r3, r3, #15
  68:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 123              		.loc 1 68 1
 124 0008 1800     		movs	r0, r3
 125 000a BD46     		mov	sp, r7
 126              		@ sp needed
 127 000c 80BD     		pop	{r7, pc}
 128              		.cfi_endproc
 129              	.LFE39:
 131              		.section	.text.HAL_RCC_GetPCLK2Freq,"ax",%progbits
 132              		.align	1
 133              		.global	HAL_RCC_GetPCLK2Freq
 134              		.syntax unified
 135              		.code	16
 136              		.thumb_func
 137              		.fpu softvfp
 139              	HAL_RCC_GetPCLK2Freq:
 140              	.LFB40:
  69:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  70:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
  71:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Returns the PCLK2 frequency
  72:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Each time PCLK2 changes, this function must be called to update the
  73:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrec
  74:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval PCLK2 frequency
  75:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
  76:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** uint32_t HAL_RCC_GetPCLK2Freq(void)
  77:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 141              		.loc 1 77 1
 142              		.cfi_startproc
 143              		@ args = 0, pretend = 0, frame = 0
 144              		@ frame_needed = 1, uses_anonymous_args = 0
 145 0000 80B5     		push	{r7, lr}
 146              	.LCFI6:
 147              		.cfi_def_cfa_offset 8
 148              		.cfi_offset 7, -8
 149              		.cfi_offset 14, -4
 150 0002 00AF     		add	r7, sp, #0
 151              	.LCFI7:
 152              		.cfi_def_cfa_register 7
  78:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  79:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_C
  80:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return 7372800;
 153              		.loc 1 80 10
 154 0004 E123     		movs	r3, #225
 155 0006 DB03     		lsls	r3, r3, #15
  81:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 156              		.loc 1 81 1
 157 0008 1800     		movs	r0, r3
 158 000a BD46     		mov	sp, r7
 159              		@ sp needed
 160 000c 80BD     		pop	{r7, pc}
 161              		.cfi_endproc
 162              	.LFE40:
 164              		.section	.text.HAL_RCC_OscConfig,"ax",%progbits
 165              		.align	1
 166              		.global	HAL_RCC_OscConfig
 167              		.syntax unified
 168              		.code	16
 169              		.thumb_func
 170              		.fpu softvfp
 172              	HAL_RCC_OscConfig:
 173              	.LFB41:
  82:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
  83:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
  84:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initializes the RCC Oscillators according to the specified parameters in the
  85:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         RCC_OscInitTypeDef.
  86:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  RCC_OscInitStruct pointer to an RCC_OscInitTypeDef structure that
  87:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         contains the configuration information for the RCC Oscillators.
  88:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The PLL is not disabled when used as system clock.
  89:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Transitions LSE Bypass to LSE On and LSE On to LSE Bypass are not
  90:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         supported by this macro. User should request a transition to LSE Off
  91:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         first and then LSE On or LSE Bypass.
  92:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   Transition HSE Bypass to HSE On and HSE On to HSE Bypass are not
  93:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         supported by this macro. User should request a transition to HSE Off
  94:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         first and then HSE On or HSE Bypass.
  95:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
  96:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
  97:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
  98:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 174              		.loc 1 98 1
 175              		.cfi_startproc
 176              		@ args = 0, pretend = 0, frame = 24
 177              		@ frame_needed = 1, uses_anonymous_args = 0
 178 0000 80B5     		push	{r7, lr}
 179              	.LCFI8:
 180              		.cfi_def_cfa_offset 8
 181              		.cfi_offset 7, -8
 182              		.cfi_offset 14, -4
 183 0002 86B0     		sub	sp, sp, #24
 184              	.LCFI9:
 185              		.cfi_def_cfa_offset 32
 186 0004 00AF     		add	r7, sp, #0
 187              	.LCFI10:
 188              		.cfi_def_cfa_register 7
 189 0006 7860     		str	r0, [r7, #4]
  99:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    uint32_t tickstart = 0U;
 190              		.loc 1 99 13
 191 0008 0023     		movs	r3, #0
 192 000a 3B61     		str	r3, [r7, #16]
 100:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 101:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 102:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(RCC_OscInitStruct != NULL);
 103:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 104:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 105:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------- HSE Configuration ------------------------*/ 
 106:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 193              		.loc 1 106 25
 194 000c 7B68     		ldr	r3, [r7, #4]
 195 000e 1B68     		ldr	r3, [r3]
 196              		.loc 1 106 43
 197 0010 0122     		movs	r2, #1
 198 0012 1340     		ands	r3, r2
 199              		.loc 1 106 5
 200 0014 00D1     		bne	.LCB129
 201 0016 8DE0     		b	.L12	@long jump
 202              	.LCB129:
 107:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 108:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 109:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 110:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 111:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowe
 112:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 203              		.loc 1 112 9
 204 0018 C34B     		ldr	r3, .L73
 205 001a 5B68     		ldr	r3, [r3, #4]
 206 001c 0C22     		movs	r2, #12
 207 001e 1340     		ands	r3, r2
 208              		.loc 1 112 7
 209 0020 042B     		cmp	r3, #4
 210 0022 0ED0     		beq	.L13
 113:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_
 211              		.loc 1 113 13
 212 0024 C04B     		ldr	r3, .L73
 213 0026 5B68     		ldr	r3, [r3, #4]
 214 0028 0C22     		movs	r2, #12
 215 002a 1340     		ands	r3, r2
 216              		.loc 1 113 8
 217 002c 082B     		cmp	r3, #8
 218 002e 16D1     		bne	.L14
 219              		.loc 1 113 82 discriminator 1
 220 0030 BD4B     		ldr	r3, .L73
 221 0032 5A68     		ldr	r2, [r3, #4]
 222 0034 8023     		movs	r3, #128
 223 0036 5B02     		lsls	r3, r3, #9
 224 0038 1A40     		ands	r2, r3
 225              		.loc 1 113 78 discriminator 1
 226 003a 8023     		movs	r3, #128
 227 003c 5B02     		lsls	r3, r3, #9
 228 003e 9A42     		cmp	r2, r3
 229 0040 0DD1     		bne	.L14
 230              	.L13:
 114:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_
 231              		.loc 1 115 11
 232 0042 B94B     		ldr	r3, .L73
 233 0044 1A68     		ldr	r2, [r3]
 234 0046 8023     		movs	r3, #128
 235 0048 9B02     		lsls	r3, r3, #10
 236 004a 1340     		ands	r3, r2
 237              		.loc 1 115 9
 238 004c 00D1     		bne	.LCB158
 239 004e 70E0     		b	.L72	@long jump
 240              	.LCB158:
 241              		.loc 1 115 78 discriminator 1
 242 0050 7B68     		ldr	r3, [r7, #4]
 243 0052 5B68     		ldr	r3, [r3, #4]
 244              		.loc 1 115 57 discriminator 1
 245 0054 002B     		cmp	r3, #0
 246 0056 00D0     		beq	.LCB162
 247 0058 6BE0     		b	.L72	@long jump
 248              	.LCB162:
 116:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 117:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 249              		.loc 1 117 16
 250 005a 0123     		movs	r3, #1
 251 005c B6E2     		b	.L16
 252              	.L14:
 118:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 119:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 120:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 121:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 122:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Set the new HSE configuration ---------------------------------------*/
 123:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 253              		.loc 1 123 7
 254 005e 7B68     		ldr	r3, [r7, #4]
 255 0060 5B68     		ldr	r3, [r3, #4]
 256 0062 012B     		cmp	r3, #1
 257 0064 07D1     		bne	.L17
 258              		.loc 1 123 7 is_stmt 0 discriminator 1
 259 0066 B04B     		ldr	r3, .L73
 260 0068 1A68     		ldr	r2, [r3]
 261 006a AF4B     		ldr	r3, .L73
 262 006c 8021     		movs	r1, #128
 263 006e 4902     		lsls	r1, r1, #9
 264 0070 0A43     		orrs	r2, r1
 265 0072 1A60     		str	r2, [r3]
 266 0074 2FE0     		b	.L18
 267              	.L17:
 268              		.loc 1 123 7 discriminator 2
 269 0076 7B68     		ldr	r3, [r7, #4]
 270 0078 5B68     		ldr	r3, [r3, #4]
 271 007a 002B     		cmp	r3, #0
 272 007c 0CD1     		bne	.L19
 273              		.loc 1 123 7 discriminator 3
 274 007e AA4B     		ldr	r3, .L73
 275 0080 1A68     		ldr	r2, [r3]
 276 0082 A94B     		ldr	r3, .L73
 277 0084 A949     		ldr	r1, .L73+4
 278 0086 0A40     		ands	r2, r1
 279 0088 1A60     		str	r2, [r3]
 280 008a A74B     		ldr	r3, .L73
 281 008c 1A68     		ldr	r2, [r3]
 282 008e A64B     		ldr	r3, .L73
 283 0090 A749     		ldr	r1, .L73+8
 284 0092 0A40     		ands	r2, r1
 285 0094 1A60     		str	r2, [r3]
 286 0096 1EE0     		b	.L18
 287              	.L19:
 288              		.loc 1 123 7 discriminator 4
 289 0098 7B68     		ldr	r3, [r7, #4]
 290 009a 5B68     		ldr	r3, [r3, #4]
 291 009c 052B     		cmp	r3, #5
 292 009e 0ED1     		bne	.L20
 293              		.loc 1 123 7 discriminator 5
 294 00a0 A14B     		ldr	r3, .L73
 295 00a2 1A68     		ldr	r2, [r3]
 296 00a4 A04B     		ldr	r3, .L73
 297 00a6 8021     		movs	r1, #128
 298 00a8 C902     		lsls	r1, r1, #11
 299 00aa 0A43     		orrs	r2, r1
 300 00ac 1A60     		str	r2, [r3]
 301 00ae 9E4B     		ldr	r3, .L73
 302 00b0 1A68     		ldr	r2, [r3]
 303 00b2 9D4B     		ldr	r3, .L73
 304 00b4 8021     		movs	r1, #128
 305 00b6 4902     		lsls	r1, r1, #9
 306 00b8 0A43     		orrs	r2, r1
 307 00ba 1A60     		str	r2, [r3]
 308 00bc 0BE0     		b	.L18
 309              	.L20:
 310              		.loc 1 123 7 discriminator 6
 311 00be 9A4B     		ldr	r3, .L73
 312 00c0 1A68     		ldr	r2, [r3]
 313 00c2 994B     		ldr	r3, .L73
 314 00c4 9949     		ldr	r1, .L73+4
 315 00c6 0A40     		ands	r2, r1
 316 00c8 1A60     		str	r2, [r3]
 317 00ca 974B     		ldr	r3, .L73
 318 00cc 1A68     		ldr	r2, [r3]
 319 00ce 964B     		ldr	r3, .L73
 320 00d0 9749     		ldr	r1, .L73+8
 321 00d2 0A40     		ands	r2, r1
 322 00d4 1A60     		str	r2, [r3]
 323              	.L18:
 124:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 125:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 126:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* Check the HSE State */
 127:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 324              		.loc 1 127 27 is_stmt 1
 325 00d6 7B68     		ldr	r3, [r7, #4]
 326 00d8 5B68     		ldr	r3, [r3, #4]
 327              		.loc 1 127 9
 328 00da 002B     		cmp	r3, #0
 329 00dc 14D0     		beq	.L21
 128:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 129:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 130:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 330              		.loc 1 130 21
 331 00de FFF7FEFF 		bl	HAL_GetTick
 332 00e2 0300     		movs	r3, r0
 333 00e4 3B61     		str	r3, [r7, #16]
 131:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 132:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSE is ready */
 133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 334              		.loc 1 133 14
 335 00e6 08E0     		b	.L22
 336              	.L23:
 134:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 135:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 337              		.loc 1 135 15
 338 00e8 FFF7FEFF 		bl	HAL_GetTick
 339 00ec 0200     		movs	r2, r0
 340              		.loc 1 135 29
 341 00ee 3B69     		ldr	r3, [r7, #16]
 342 00f0 D31A     		subs	r3, r2, r3
 343              		.loc 1 135 13
 344 00f2 642B     		cmp	r3, #100
 345 00f4 01D9     		bls	.L22
 136:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 137:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 346              		.loc 1 137 20
 347 00f6 0323     		movs	r3, #3
 348 00f8 68E2     		b	.L16
 349              	.L22:
 133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 350              		.loc 1 133 15
 351 00fa 8B4B     		ldr	r3, .L73
 352 00fc 1A68     		ldr	r2, [r3]
 353 00fe 8023     		movs	r3, #128
 354 0100 9B02     		lsls	r3, r3, #10
 355 0102 1340     		ands	r3, r2
 133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 356              		.loc 1 133 51
 357 0104 F0D0     		beq	.L23
 358 0106 15E0     		b	.L12
 359              	.L21:
 138:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 139:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 140:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 141:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 142:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 143:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 144:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 360              		.loc 1 144 21
 361 0108 FFF7FEFF 		bl	HAL_GetTick
 362 010c 0300     		movs	r3, r0
 363 010e 3B61     		str	r3, [r7, #16]
 145:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 146:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSE is disabled */
 147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 364              		.loc 1 147 14
 365 0110 08E0     		b	.L24
 366              	.L25:
 148:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 149:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****            if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 367              		.loc 1 149 16
 368 0112 FFF7FEFF 		bl	HAL_GetTick
 369 0116 0200     		movs	r2, r0
 370              		.loc 1 149 30
 371 0118 3B69     		ldr	r3, [r7, #16]
 372 011a D31A     		subs	r3, r2, r3
 373              		.loc 1 149 14
 374 011c 642B     		cmp	r3, #100
 375 011e 01D9     		bls	.L24
 150:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 151:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 376              		.loc 1 151 20
 377 0120 0323     		movs	r3, #3
 378 0122 53E2     		b	.L16
 379              	.L24:
 147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 380              		.loc 1 147 15
 381 0124 804B     		ldr	r3, .L73
 382 0126 1A68     		ldr	r2, [r3]
 383 0128 8023     		movs	r3, #128
 384 012a 9B02     		lsls	r3, r3, #10
 385 012c 1340     		ands	r3, r2
 147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 386              		.loc 1 147 51
 387 012e F0D1     		bne	.L25
 388 0130 00E0     		b	.L12
 389              	.L72:
 115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 390              		.loc 1 115 9
 391 0132 C046     		nop
 392              	.L12:
 152:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 153:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 154:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 155:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 156:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 157:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI Configuration --------------------------*/ 
 158:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 393              		.loc 1 158 25
 394 0134 7B68     		ldr	r3, [r7, #4]
 395 0136 1B68     		ldr	r3, [r3]
 396              		.loc 1 158 43
 397 0138 0222     		movs	r2, #2
 398 013a 1340     		ands	r3, r2
 399              		.loc 1 158 5
 400 013c 00D1     		bne	.LCB309
 401 013e 69E0     		b	.L26	@long jump
 402              	.LCB309:
 159:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 160:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 161:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 162:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 163:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 164:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock *
 165:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 403              		.loc 1 165 9
 404 0140 794B     		ldr	r3, .L73
 405 0142 5B68     		ldr	r3, [r3, #4]
 406 0144 0C22     		movs	r2, #12
 407 0146 1340     		ands	r3, r2
 408              		.loc 1 165 7
 409 0148 0BD0     		beq	.L27
 166:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_
 410              		.loc 1 166 13
 411 014a 774B     		ldr	r3, .L73
 412 014c 5B68     		ldr	r3, [r3, #4]
 413 014e 0C22     		movs	r2, #12
 414 0150 1340     		ands	r3, r2
 415              		.loc 1 166 8
 416 0152 082B     		cmp	r3, #8
 417 0154 1CD1     		bne	.L28
 418              		.loc 1 166 82 discriminator 1
 419 0156 744B     		ldr	r3, .L73
 420 0158 5A68     		ldr	r2, [r3, #4]
 421 015a 8023     		movs	r3, #128
 422 015c 5B02     		lsls	r3, r3, #9
 423 015e 1340     		ands	r3, r2
 424              		.loc 1 166 78 discriminator 1
 425 0160 16D1     		bne	.L28
 426              	.L27:
 167:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 168:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* When HSI is used as system clock it will not disabled */
 169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_
 427              		.loc 1 169 11
 428 0162 714B     		ldr	r3, .L73
 429 0164 1B68     		ldr	r3, [r3]
 430 0166 0222     		movs	r2, #2
 431 0168 1340     		ands	r3, r2
 432              		.loc 1 169 9
 433 016a 05D0     		beq	.L29
 434              		.loc 1 169 78 discriminator 1
 435 016c 7B68     		ldr	r3, [r7, #4]
 436 016e DB68     		ldr	r3, [r3, #12]
 437              		.loc 1 169 57 discriminator 1
 438 0170 012B     		cmp	r3, #1
 439 0172 01D0     		beq	.L29
 170:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 171:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 440              		.loc 1 171 16
 441 0174 0123     		movs	r3, #1
 442 0176 29E2     		b	.L16
 443              	.L29:
 172:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 173:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Otherwise, just the calibration is allowed */
 174:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 175:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 176:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 177:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 444              		.loc 1 177 9
 445 0178 6B4B     		ldr	r3, .L73
 446 017a 1B68     		ldr	r3, [r3]
 447 017c F822     		movs	r2, #248
 448 017e 9343     		bics	r3, r2
 449 0180 1900     		movs	r1, r3
 450 0182 7B68     		ldr	r3, [r7, #4]
 451 0184 1B69     		ldr	r3, [r3, #16]
 452 0186 DA00     		lsls	r2, r3, #3
 453 0188 674B     		ldr	r3, .L73
 454 018a 0A43     		orrs	r2, r1
 455 018c 1A60     		str	r2, [r3]
 169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 456              		.loc 1 169 9
 457 018e 41E0     		b	.L26
 458              	.L28:
 178:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 179:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 180:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 181:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 182:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI State */
 183:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 459              		.loc 1 183 27
 460 0190 7B68     		ldr	r3, [r7, #4]
 461 0192 DB68     		ldr	r3, [r3, #12]
 462              		.loc 1 183 9
 463 0194 002B     		cmp	r3, #0
 464 0196 24D0     		beq	.L30
 184:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 185:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* Enable the Internal High Speed oscillator (HSI). */
 186:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_ENABLE();
 465              		.loc 1 186 9
 466 0198 634B     		ldr	r3, .L73
 467 019a 1A68     		ldr	r2, [r3]
 468 019c 624B     		ldr	r3, .L73
 469 019e 0121     		movs	r1, #1
 470 01a0 0A43     		orrs	r2, r1
 471 01a2 1A60     		str	r2, [r3]
 187:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 188:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 189:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 472              		.loc 1 189 21
 473 01a4 FFF7FEFF 		bl	HAL_GetTick
 474 01a8 0300     		movs	r3, r0
 475 01aa 3B61     		str	r3, [r7, #16]
 190:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 191:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI is ready */
 192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 476              		.loc 1 192 14
 477 01ac 08E0     		b	.L31
 478              	.L32:
 193:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 194:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 479              		.loc 1 194 15
 480 01ae FFF7FEFF 		bl	HAL_GetTick
 481 01b2 0200     		movs	r2, r0
 482              		.loc 1 194 29
 483 01b4 3B69     		ldr	r3, [r7, #16]
 484 01b6 D31A     		subs	r3, r2, r3
 485              		.loc 1 194 13
 486 01b8 022B     		cmp	r3, #2
 487 01ba 01D9     		bls	.L31
 195:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 196:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 488              		.loc 1 196 20
 489 01bc 0323     		movs	r3, #3
 490 01be 05E2     		b	.L16
 491              	.L31:
 192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 492              		.loc 1 192 15
 493 01c0 594B     		ldr	r3, .L73
 494 01c2 1B68     		ldr	r3, [r3]
 495 01c4 0222     		movs	r2, #2
 496 01c6 1340     		ands	r3, r2
 192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 497              		.loc 1 192 51
 498 01c8 F1D0     		beq	.L32
 197:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 198:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 199:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                 
 200:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
 201:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 499              		.loc 1 201 9
 500 01ca 574B     		ldr	r3, .L73
 501 01cc 1B68     		ldr	r3, [r3]
 502 01ce F822     		movs	r2, #248
 503 01d0 9343     		bics	r3, r2
 504 01d2 1900     		movs	r1, r3
 505 01d4 7B68     		ldr	r3, [r7, #4]
 506 01d6 1B69     		ldr	r3, [r3, #16]
 507 01d8 DA00     		lsls	r2, r3, #3
 508 01da 534B     		ldr	r3, .L73
 509 01dc 0A43     		orrs	r2, r1
 510 01de 1A60     		str	r2, [r3]
 511 01e0 18E0     		b	.L26
 512              	.L30:
 202:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 203:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 204:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 205:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the Internal High Speed oscillator (HSI). */
 206:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI_DISABLE();
 513              		.loc 1 206 9
 514 01e2 514B     		ldr	r3, .L73
 515 01e4 1A68     		ldr	r2, [r3]
 516 01e6 504B     		ldr	r3, .L73
 517 01e8 0121     		movs	r1, #1
 518 01ea 8A43     		bics	r2, r1
 519 01ec 1A60     		str	r2, [r3]
 207:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 208:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 209:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 520              		.loc 1 209 21
 521 01ee FFF7FEFF 		bl	HAL_GetTick
 522 01f2 0300     		movs	r3, r0
 523 01f4 3B61     		str	r3, [r7, #16]
 210:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 211:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI is disabled */
 212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 524              		.loc 1 212 14
 525 01f6 08E0     		b	.L33
 526              	.L34:
 213:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 214:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 527              		.loc 1 214 15
 528 01f8 FFF7FEFF 		bl	HAL_GetTick
 529 01fc 0200     		movs	r2, r0
 530              		.loc 1 214 29
 531 01fe 3B69     		ldr	r3, [r7, #16]
 532 0200 D31A     		subs	r3, r2, r3
 533              		.loc 1 214 13
 534 0202 022B     		cmp	r3, #2
 535 0204 01D9     		bls	.L33
 215:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 216:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 536              		.loc 1 216 20
 537 0206 0323     		movs	r3, #3
 538 0208 E0E1     		b	.L16
 539              	.L33:
 212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 540              		.loc 1 212 15
 541 020a 474B     		ldr	r3, .L73
 542 020c 1B68     		ldr	r3, [r3]
 543 020e 0222     		movs	r2, #2
 544 0210 1340     		ands	r3, r2
 212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 545              		.loc 1 212 51
 546 0212 F1D1     		bne	.L34
 547              	.L26:
 217:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 218:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 219:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 220:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 221:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 222:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ LSI Configuration -------------------------*/ 
 223:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 548              		.loc 1 223 25
 549 0214 7B68     		ldr	r3, [r7, #4]
 550 0216 1B68     		ldr	r3, [r3]
 551              		.loc 1 223 43
 552 0218 0822     		movs	r2, #8
 553 021a 1340     		ands	r3, r2
 554              		.loc 1 223 5
 555 021c 36D0     		beq	.L35
 224:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 225:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 226:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 227:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 228:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the LSI State */
 229:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 556              		.loc 1 229 25
 557 021e 7B68     		ldr	r3, [r7, #4]
 558 0220 DB69     		ldr	r3, [r3, #28]
 559              		.loc 1 229 7
 560 0222 002B     		cmp	r3, #0
 561 0224 19D0     		beq	.L36
 230:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 231:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable the Internal Low Speed oscillator (LSI). */
 232:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_LSI_ENABLE();
 562              		.loc 1 232 7
 563 0226 404B     		ldr	r3, .L73
 564 0228 5A6A     		ldr	r2, [r3, #36]
 565 022a 3F4B     		ldr	r3, .L73
 566 022c 0121     		movs	r1, #1
 567 022e 0A43     		orrs	r2, r1
 568 0230 5A62     		str	r2, [r3, #36]
 233:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 234:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 235:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 569              		.loc 1 235 19
 570 0232 FFF7FEFF 		bl	HAL_GetTick
 571 0236 0300     		movs	r3, r0
 572 0238 3B61     		str	r3, [r7, #16]
 236:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 237:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSI is ready */  
 238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 573              		.loc 1 238 12
 574 023a 08E0     		b	.L37
 575              	.L38:
 239:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 240:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 576              		.loc 1 240 13
 577 023c FFF7FEFF 		bl	HAL_GetTick
 578 0240 0200     		movs	r2, r0
 579              		.loc 1 240 27
 580 0242 3B69     		ldr	r3, [r7, #16]
 581 0244 D31A     		subs	r3, r2, r3
 582              		.loc 1 240 11
 583 0246 022B     		cmp	r3, #2
 584 0248 01D9     		bls	.L37
 241:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 242:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 585              		.loc 1 242 18
 586 024a 0323     		movs	r3, #3
 587 024c BEE1     		b	.L16
 588              	.L37:
 238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 589              		.loc 1 238 13
 590 024e 364B     		ldr	r3, .L73
 591 0250 5B6A     		ldr	r3, [r3, #36]
 592 0252 0222     		movs	r2, #2
 593 0254 1340     		ands	r3, r2
 238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 594              		.loc 1 238 49
 595 0256 F1D0     		beq	.L38
 596 0258 18E0     		b	.L35
 597              	.L36:
 243:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 244:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 245:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 246:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 247:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 248:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable the Internal Low Speed oscillator (LSI). */
 249:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_LSI_DISABLE();
 598              		.loc 1 249 7
 599 025a 334B     		ldr	r3, .L73
 600 025c 5A6A     		ldr	r2, [r3, #36]
 601 025e 324B     		ldr	r3, .L73
 602 0260 0121     		movs	r1, #1
 603 0262 8A43     		bics	r2, r1
 604 0264 5A62     		str	r2, [r3, #36]
 250:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 251:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 252:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 605              		.loc 1 252 19
 606 0266 FFF7FEFF 		bl	HAL_GetTick
 607 026a 0300     		movs	r3, r0
 608 026c 3B61     		str	r3, [r7, #16]
 253:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 254:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSI is disabled */  
 255:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 609              		.loc 1 255 12
 610 026e 08E0     		b	.L39
 611              	.L40:
 256:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 257:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 612              		.loc 1 257 13
 613 0270 FFF7FEFF 		bl	HAL_GetTick
 614 0274 0200     		movs	r2, r0
 615              		.loc 1 257 27
 616 0276 3B69     		ldr	r3, [r7, #16]
 617 0278 D31A     		subs	r3, r2, r3
 618              		.loc 1 257 11
 619 027a 022B     		cmp	r3, #2
 620 027c 01D9     		bls	.L39
 258:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 259:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 621              		.loc 1 259 18
 622 027e 0323     		movs	r3, #3
 623 0280 A4E1     		b	.L16
 624              	.L39:
 255:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 625              		.loc 1 255 13
 626 0282 294B     		ldr	r3, .L73
 627 0284 5B6A     		ldr	r3, [r3, #36]
 628 0286 0222     		movs	r2, #2
 629 0288 1340     		ands	r3, r2
 255:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 630              		.loc 1 255 49
 631 028a F1D1     		bne	.L40
 632              	.L35:
 260:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 261:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 262:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 263:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 264:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ LSE Configuration -------------------------*/ 
 265:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 633              		.loc 1 265 25
 634 028c 7B68     		ldr	r3, [r7, #4]
 635 028e 1B68     		ldr	r3, [r3]
 636              		.loc 1 265 43
 637 0290 0422     		movs	r2, #4
 638 0292 1340     		ands	r3, r2
 639              		.loc 1 265 5
 640 0294 00D1     		bne	.LCB520
 641 0296 B5E0     		b	.L41	@long jump
 642              	.LCB520:
 643              	.LBB2:
 266:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 267:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     FlagStatus       pwrclkchanged = RESET;
 644              		.loc 1 267 22
 645 0298 1720     		movs	r0, #23
 646 029a 3B18     		adds	r3, r7, r0
 647 029c 0022     		movs	r2, #0
 648 029e 1A70     		strb	r2, [r3]
 268:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 269:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 270:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 271:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 272:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Update LSE configuration in Backup Domain control register    */
 273:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Requires to enable write access to Backup Domain of necessary */
 274:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 649              		.loc 1 274 8
 650 02a0 214B     		ldr	r3, .L73
 651 02a2 DA69     		ldr	r2, [r3, #28]
 652 02a4 8023     		movs	r3, #128
 653 02a6 5B05     		lsls	r3, r3, #21
 654 02a8 1340     		ands	r3, r2
 655              		.loc 1 274 7
 656 02aa 10D1     		bne	.L42
 657              	.LBB3:
 275:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 276:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_ENABLE();
 658              		.loc 1 276 7
 659 02ac 1E4B     		ldr	r3, .L73
 660 02ae DA69     		ldr	r2, [r3, #28]
 661 02b0 1D4B     		ldr	r3, .L73
 662 02b2 8021     		movs	r1, #128
 663 02b4 4905     		lsls	r1, r1, #21
 664 02b6 0A43     		orrs	r2, r1
 665 02b8 DA61     		str	r2, [r3, #28]
 666 02ba 1B4B     		ldr	r3, .L73
 667 02bc DA69     		ldr	r2, [r3, #28]
 668 02be 8023     		movs	r3, #128
 669 02c0 5B05     		lsls	r3, r3, #21
 670 02c2 1340     		ands	r3, r2
 671 02c4 FB60     		str	r3, [r7, #12]
 672 02c6 FB68     		ldr	r3, [r7, #12]
 673              	.LBE3:
 277:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       pwrclkchanged = SET;
 674              		.loc 1 277 21
 675 02c8 3B18     		adds	r3, r7, r0
 676 02ca 0122     		movs	r2, #1
 677 02cc 1A70     		strb	r2, [r3]
 678              	.L42:
 278:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 279:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 280:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 679              		.loc 1 280 8
 680 02ce 194B     		ldr	r3, .L73+12
 681 02d0 1A68     		ldr	r2, [r3]
 682 02d2 8023     		movs	r3, #128
 683 02d4 5B00     		lsls	r3, r3, #1
 684 02d6 1340     		ands	r3, r2
 685              		.loc 1 280 7
 686 02d8 1AD1     		bne	.L43
 281:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 282:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable write access to Backup domain */
 283:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(PWR->CR, PWR_CR_DBP);
 687              		.loc 1 283 7
 688 02da 164B     		ldr	r3, .L73+12
 689 02dc 1A68     		ldr	r2, [r3]
 690 02de 154B     		ldr	r3, .L73+12
 691 02e0 8021     		movs	r1, #128
 692 02e2 4900     		lsls	r1, r1, #1
 693 02e4 0A43     		orrs	r2, r1
 694 02e6 1A60     		str	r2, [r3]
 284:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 285:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for Backup domain Write protection disable */
 286:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 695              		.loc 1 286 19
 696 02e8 FFF7FEFF 		bl	HAL_GetTick
 697 02ec 0300     		movs	r3, r0
 698 02ee 3B61     		str	r3, [r7, #16]
 287:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 699              		.loc 1 288 12
 700 02f0 08E0     		b	.L44
 701              	.L45:
 289:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 290:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 702              		.loc 1 290 13
 703 02f2 FFF7FEFF 		bl	HAL_GetTick
 704 02f6 0200     		movs	r2, r0
 705              		.loc 1 290 27
 706 02f8 3B69     		ldr	r3, [r7, #16]
 707 02fa D31A     		subs	r3, r2, r3
 708              		.loc 1 290 11
 709 02fc 642B     		cmp	r3, #100
 710 02fe 01D9     		bls	.L44
 291:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 292:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 711              		.loc 1 292 18
 712 0300 0323     		movs	r3, #3
 713 0302 63E1     		b	.L16
 714              	.L44:
 288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 715              		.loc 1 288 13
 716 0304 0B4B     		ldr	r3, .L73+12
 717 0306 1A68     		ldr	r2, [r3]
 718 0308 8023     		movs	r3, #128
 719 030a 5B00     		lsls	r3, r3, #1
 720 030c 1340     		ands	r3, r2
 721 030e F0D0     		beq	.L45
 722              	.L43:
 293:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 294:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 295:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 296:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 297:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Set the new LSE configuration -----------------------------------------*/
 298:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 723              		.loc 1 298 5
 724 0310 7B68     		ldr	r3, [r7, #4]
 725 0312 9B68     		ldr	r3, [r3, #8]
 726 0314 012B     		cmp	r3, #1
 727 0316 0FD1     		bne	.L46
 728              		.loc 1 298 5 is_stmt 0 discriminator 1
 729 0318 034B     		ldr	r3, .L73
 730 031a 1A6A     		ldr	r2, [r3, #32]
 731 031c 024B     		ldr	r3, .L73
 732 031e 0121     		movs	r1, #1
 733 0320 0A43     		orrs	r2, r1
 734 0322 1A62     		str	r2, [r3, #32]
 735 0324 36E0     		b	.L47
 736              	.L74:
 737 0326 C046     		.align	2
 738              	.L73:
 739 0328 00100240 		.word	1073876992
 740 032c FFFFFEFF 		.word	-65537
 741 0330 FFFFFBFF 		.word	-262145
 742 0334 00700040 		.word	1073770496
 743              	.L46:
 744              		.loc 1 298 5 discriminator 2
 745 0338 7B68     		ldr	r3, [r7, #4]
 746 033a 9B68     		ldr	r3, [r3, #8]
 747 033c 002B     		cmp	r3, #0
 748 033e 0CD1     		bne	.L48
 749              		.loc 1 298 5 discriminator 3
 750 0340 A44B     		ldr	r3, .L75
 751 0342 1A6A     		ldr	r2, [r3, #32]
 752 0344 A34B     		ldr	r3, .L75
 753 0346 0121     		movs	r1, #1
 754 0348 8A43     		bics	r2, r1
 755 034a 1A62     		str	r2, [r3, #32]
 756 034c A14B     		ldr	r3, .L75
 757 034e 1A6A     		ldr	r2, [r3, #32]
 758 0350 A04B     		ldr	r3, .L75
 759 0352 0421     		movs	r1, #4
 760 0354 8A43     		bics	r2, r1
 761 0356 1A62     		str	r2, [r3, #32]
 762 0358 1CE0     		b	.L47
 763              	.L48:
 764              		.loc 1 298 5 discriminator 4
 765 035a 7B68     		ldr	r3, [r7, #4]
 766 035c 9B68     		ldr	r3, [r3, #8]
 767 035e 052B     		cmp	r3, #5
 768 0360 0CD1     		bne	.L49
 769              		.loc 1 298 5 discriminator 5
 770 0362 9C4B     		ldr	r3, .L75
 771 0364 1A6A     		ldr	r2, [r3, #32]
 772 0366 9B4B     		ldr	r3, .L75
 773 0368 0421     		movs	r1, #4
 774 036a 0A43     		orrs	r2, r1
 775 036c 1A62     		str	r2, [r3, #32]
 776 036e 994B     		ldr	r3, .L75
 777 0370 1A6A     		ldr	r2, [r3, #32]
 778 0372 984B     		ldr	r3, .L75
 779 0374 0121     		movs	r1, #1
 780 0376 0A43     		orrs	r2, r1
 781 0378 1A62     		str	r2, [r3, #32]
 782 037a 0BE0     		b	.L47
 783              	.L49:
 784              		.loc 1 298 5 discriminator 6
 785 037c 954B     		ldr	r3, .L75
 786 037e 1A6A     		ldr	r2, [r3, #32]
 787 0380 944B     		ldr	r3, .L75
 788 0382 0121     		movs	r1, #1
 789 0384 8A43     		bics	r2, r1
 790 0386 1A62     		str	r2, [r3, #32]
 791 0388 924B     		ldr	r3, .L75
 792 038a 1A6A     		ldr	r2, [r3, #32]
 793 038c 914B     		ldr	r3, .L75
 794 038e 0421     		movs	r1, #4
 795 0390 8A43     		bics	r2, r1
 796 0392 1A62     		str	r2, [r3, #32]
 797              	.L47:
 299:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the LSE State */
 300:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 798              		.loc 1 300 25 is_stmt 1
 799 0394 7B68     		ldr	r3, [r7, #4]
 800 0396 9B68     		ldr	r3, [r3, #8]
 801              		.loc 1 300 7
 802 0398 002B     		cmp	r3, #0
 803 039a 14D0     		beq	.L50
 301:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 302:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 303:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 804              		.loc 1 303 19
 805 039c FFF7FEFF 		bl	HAL_GetTick
 806 03a0 0300     		movs	r3, r0
 807 03a2 3B61     		str	r3, [r7, #16]
 304:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 305:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSE is ready */  
 306:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 808              		.loc 1 306 12
 809 03a4 09E0     		b	.L51
 810              	.L52:
 307:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 308:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 811              		.loc 1 308 13
 812 03a6 FFF7FEFF 		bl	HAL_GetTick
 813 03aa 0200     		movs	r2, r0
 814              		.loc 1 308 27
 815 03ac 3B69     		ldr	r3, [r7, #16]
 816 03ae D31A     		subs	r3, r2, r3
 817              		.loc 1 308 11
 818 03b0 894A     		ldr	r2, .L75+4
 819 03b2 9342     		cmp	r3, r2
 820 03b4 01D9     		bls	.L51
 309:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 310:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 821              		.loc 1 310 18
 822 03b6 0323     		movs	r3, #3
 823 03b8 08E1     		b	.L16
 824              	.L51:
 306:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 825              		.loc 1 306 13
 826 03ba 864B     		ldr	r3, .L75
 827 03bc 1B6A     		ldr	r3, [r3, #32]
 828 03be 0222     		movs	r2, #2
 829 03c0 1340     		ands	r3, r2
 306:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 830              		.loc 1 306 49
 831 03c2 F0D0     		beq	.L52
 832 03c4 13E0     		b	.L53
 833              	.L50:
 311:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 312:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 313:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 314:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 315:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 316:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 317:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 834              		.loc 1 317 19
 835 03c6 FFF7FEFF 		bl	HAL_GetTick
 836 03ca 0300     		movs	r3, r0
 837 03cc 3B61     		str	r3, [r7, #16]
 318:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 319:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till LSE is disabled */  
 320:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 838              		.loc 1 320 12
 839 03ce 09E0     		b	.L54
 840              	.L55:
 321:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 322:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 841              		.loc 1 322 13
 842 03d0 FFF7FEFF 		bl	HAL_GetTick
 843 03d4 0200     		movs	r2, r0
 844              		.loc 1 322 27
 845 03d6 3B69     		ldr	r3, [r7, #16]
 846 03d8 D31A     		subs	r3, r2, r3
 847              		.loc 1 322 11
 848 03da 7F4A     		ldr	r2, .L75+4
 849 03dc 9342     		cmp	r3, r2
 850 03de 01D9     		bls	.L54
 323:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 324:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 851              		.loc 1 324 18
 852 03e0 0323     		movs	r3, #3
 853 03e2 F3E0     		b	.L16
 854              	.L54:
 320:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 855              		.loc 1 320 13
 856 03e4 7B4B     		ldr	r3, .L75
 857 03e6 1B6A     		ldr	r3, [r3, #32]
 858 03e8 0222     		movs	r2, #2
 859 03ea 1340     		ands	r3, r2
 320:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 860              		.loc 1 320 49
 861 03ec F0D1     		bne	.L55
 862              	.L53:
 325:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 326:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 327:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 328:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 329:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Require to disable power clock if necessary */
 330:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(pwrclkchanged == SET)
 863              		.loc 1 330 7
 864 03ee 1723     		movs	r3, #23
 865 03f0 FB18     		adds	r3, r7, r3
 866 03f2 1B78     		ldrb	r3, [r3]
 867 03f4 012B     		cmp	r3, #1
 868 03f6 05D1     		bne	.L41
 331:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 332:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_DISABLE();
 869              		.loc 1 332 7
 870 03f8 764B     		ldr	r3, .L75
 871 03fa DA69     		ldr	r2, [r3, #28]
 872 03fc 754B     		ldr	r3, .L75
 873 03fe 7749     		ldr	r1, .L75+8
 874 0400 0A40     		ands	r2, r1
 875 0402 DA61     		str	r2, [r3, #28]
 876              	.L41:
 877              	.LBE2:
 333:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 334:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 335:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 336:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI14 Configuration --------------------------*/
 337:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 878              		.loc 1 337 25
 879 0404 7B68     		ldr	r3, [r7, #4]
 880 0406 1B68     		ldr	r3, [r3]
 881              		.loc 1 337 43
 882 0408 1022     		movs	r2, #16
 883 040a 1340     		ands	r3, r2
 884              		.loc 1 337 5
 885 040c 63D0     		beq	.L56
 338:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 339:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 340:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI14(RCC_OscInitStruct->HSI14State));
 341:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSI14CalibrationValue));
 342:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 343:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the HSI14 State */
 344:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 886              		.loc 1 344 25
 887 040e 7B68     		ldr	r3, [r7, #4]
 888 0410 5B69     		ldr	r3, [r3, #20]
 889              		.loc 1 344 7
 890 0412 012B     		cmp	r3, #1
 891 0414 2AD1     		bne	.L57
 345:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 346:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable ADC control of the Internal High Speed oscillator HSI14 */
 347:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_DISABLE();
 892              		.loc 1 347 7
 893 0416 6F4B     		ldr	r3, .L75
 894 0418 5A6B     		ldr	r2, [r3, #52]
 895 041a 6E4B     		ldr	r3, .L75
 896 041c 0421     		movs	r1, #4
 897 041e 0A43     		orrs	r2, r1
 898 0420 5A63     		str	r2, [r3, #52]
 348:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 349:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable the Internal High Speed oscillator (HSI). */
 350:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_ENABLE();
 899              		.loc 1 350 7
 900 0422 6C4B     		ldr	r3, .L75
 901 0424 5A6B     		ldr	r2, [r3, #52]
 902 0426 6B4B     		ldr	r3, .L75
 903 0428 0121     		movs	r1, #1
 904 042a 0A43     		orrs	r2, r1
 905 042c 5A63     		str	r2, [r3, #52]
 351:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 352:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 353:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 906              		.loc 1 353 19
 907 042e FFF7FEFF 		bl	HAL_GetTick
 908 0432 0300     		movs	r3, r0
 909 0434 3B61     		str	r3, [r7, #16]
 354:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 355:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till HSI is ready */  
 356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 910              		.loc 1 356 12
 911 0436 08E0     		b	.L58
 912              	.L59:
 357:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 358:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 913              		.loc 1 358 13
 914 0438 FFF7FEFF 		bl	HAL_GetTick
 915 043c 0200     		movs	r2, r0
 916              		.loc 1 358 27
 917 043e 3B69     		ldr	r3, [r7, #16]
 918 0440 D31A     		subs	r3, r2, r3
 919              		.loc 1 358 11
 920 0442 022B     		cmp	r3, #2
 921 0444 01D9     		bls	.L58
 359:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 360:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 922              		.loc 1 360 18
 923 0446 0323     		movs	r3, #3
 924 0448 C0E0     		b	.L16
 925              	.L58:
 356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 926              		.loc 1 356 13
 927 044a 624B     		ldr	r3, .L75
 928 044c 5B6B     		ldr	r3, [r3, #52]
 929 044e 0222     		movs	r2, #2
 930 0450 1340     		ands	r3, r2
 356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 931              		.loc 1 356 51
 932 0452 F1D0     		beq	.L59
 361:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }      
 362:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       } 
 363:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 364:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
 365:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 933              		.loc 1 365 7
 934 0454 5F4B     		ldr	r3, .L75
 935 0456 5B6B     		ldr	r3, [r3, #52]
 936 0458 F822     		movs	r2, #248
 937 045a 9343     		bics	r3, r2
 938 045c 1900     		movs	r1, r3
 939 045e 7B68     		ldr	r3, [r7, #4]
 940 0460 9B69     		ldr	r3, [r3, #24]
 941 0462 DA00     		lsls	r2, r3, #3
 942 0464 5B4B     		ldr	r3, .L75
 943 0466 0A43     		orrs	r2, r1
 944 0468 5A63     		str	r2, [r3, #52]
 945 046a 34E0     		b	.L56
 946              	.L57:
 366:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 367:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 947              		.loc 1 367 30
 948 046c 7B68     		ldr	r3, [r7, #4]
 949 046e 5B69     		ldr	r3, [r3, #20]
 950              		.loc 1 367 12
 951 0470 0533     		adds	r3, r3, #5
 952 0472 11D1     		bne	.L60
 368:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 369:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable ADC control of the Internal High Speed oscillator HSI14 */
 370:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_ENABLE();
 953              		.loc 1 370 7
 954 0474 574B     		ldr	r3, .L75
 955 0476 5A6B     		ldr	r2, [r3, #52]
 956 0478 564B     		ldr	r3, .L75
 957 047a 0421     		movs	r1, #4
 958 047c 8A43     		bics	r2, r1
 959 047e 5A63     		str	r2, [r3, #52]
 371:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 372:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Adjusts the Internal High Speed oscillator 14Mhz (HSI14) calibration value. */
 373:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 960              		.loc 1 373 7
 961 0480 544B     		ldr	r3, .L75
 962 0482 5B6B     		ldr	r3, [r3, #52]
 963 0484 F822     		movs	r2, #248
 964 0486 9343     		bics	r3, r2
 965 0488 1900     		movs	r1, r3
 966 048a 7B68     		ldr	r3, [r7, #4]
 967 048c 9B69     		ldr	r3, [r3, #24]
 968 048e DA00     		lsls	r2, r3, #3
 969 0490 504B     		ldr	r3, .L75
 970 0492 0A43     		orrs	r2, r1
 971 0494 5A63     		str	r2, [r3, #52]
 972 0496 1EE0     		b	.L56
 973              	.L60:
 374:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 376:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 377:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable ADC control of the Internal High Speed oscillator HSI14 */
 378:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14ADC_DISABLE();
 974              		.loc 1 378 7
 975 0498 4E4B     		ldr	r3, .L75
 976 049a 5A6B     		ldr	r2, [r3, #52]
 977 049c 4D4B     		ldr	r3, .L75
 978 049e 0421     		movs	r1, #4
 979 04a0 0A43     		orrs	r2, r1
 980 04a2 5A63     		str	r2, [r3, #52]
 379:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 380:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Disable the Internal High Speed oscillator (HSI). */
 381:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_HSI14_DISABLE();
 981              		.loc 1 381 7
 982 04a4 4B4B     		ldr	r3, .L75
 983 04a6 5A6B     		ldr	r2, [r3, #52]
 984 04a8 4A4B     		ldr	r3, .L75
 985 04aa 0121     		movs	r1, #1
 986 04ac 8A43     		bics	r2, r1
 987 04ae 5A63     		str	r2, [r3, #52]
 382:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 383:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Get Start Tick */
 384:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 988              		.loc 1 384 19
 989 04b0 FFF7FEFF 		bl	HAL_GetTick
 990 04b4 0300     		movs	r3, r0
 991 04b6 3B61     		str	r3, [r7, #16]
 385:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 386:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait till HSI is ready */  
 387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 992              		.loc 1 387 12
 993 04b8 08E0     		b	.L61
 994              	.L62:
 388:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 389:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 995              		.loc 1 389 13
 996 04ba FFF7FEFF 		bl	HAL_GetTick
 997 04be 0200     		movs	r2, r0
 998              		.loc 1 389 27
 999 04c0 3B69     		ldr	r3, [r7, #16]
 1000 04c2 D31A     		subs	r3, r2, r3
 1001              		.loc 1 389 11
 1002 04c4 022B     		cmp	r3, #2
 1003 04c6 01D9     		bls	.L61
 390:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 391:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1004              		.loc 1 391 18
 1005 04c8 0323     		movs	r3, #3
 1006 04ca 7FE0     		b	.L16
 1007              	.L61:
 387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1008              		.loc 1 387 13
 1009 04cc 414B     		ldr	r3, .L75
 1010 04ce 5B6B     		ldr	r3, [r3, #52]
 1011 04d0 0222     		movs	r2, #2
 1012 04d2 1340     		ands	r3, r2
 387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1013              		.loc 1 387 51
 1014 04d4 F1D1     		bne	.L62
 1015              	.L56:
 392:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 393:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 394:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 395:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 396:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 397:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_HSI48_SUPPORT)
 398:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- HSI48 Configuration --------------------------*/
 399:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 400:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 401:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 402:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 403:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 404:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* When the HSI48 is used as system clock it is not allowed to be disabled */
 405:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI48) ||
 406:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSC
 407:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 408:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET) && (RCC_OscInitStruct->HSI48State != RCC_
 409:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 410:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 411:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 412:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 413:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 414:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 415:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI48 State */
 416:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 417:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 418:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable the Internal High Speed oscillator (HSI48). */
 419:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI48_ENABLE();
 420:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 421:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 422:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 423:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 424:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI48 is ready */  
 425:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 426:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 427:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 428:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 429:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 430:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 431:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         } 
 432:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 433:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 434:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 435:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the Internal High Speed oscillator (HSI48). */
 436:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_HSI48_DISABLE();
 437:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 438:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 439:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 440:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 441:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till HSI48 is ready */  
 442:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != RESET)
 443:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 444:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 445:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 446:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 447:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 448:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 449:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 450:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 451:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 452:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_HSI48_SUPPORT */
 453:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        
 454:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------------- PLL Configuration -----------------------*/
 455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 456:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 457:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 1016              		.loc 1 457 30
 1017 04d6 7B68     		ldr	r3, [r7, #4]
 1018 04d8 1B6A     		ldr	r3, [r3, #32]
 1019              		.loc 1 457 6
 1020 04da 002B     		cmp	r3, #0
 1021 04dc 00D1     		bne	.LCB871
 1022 04de 74E0     		b	.L63	@long jump
 1023              	.LCB871:
 458:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 459:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the PLL is used as system clock or not */
 460:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 1024              		.loc 1 460 8
 1025 04e0 3C4B     		ldr	r3, .L75
 1026 04e2 5B68     		ldr	r3, [r3, #4]
 1027 04e4 0C22     		movs	r2, #12
 1028 04e6 1340     		ands	r3, r2
 1029              		.loc 1 460 7
 1030 04e8 082B     		cmp	r3, #8
 1031 04ea 00D1     		bne	.LCB877
 1032 04ec 6BE0     		b	.L64	@long jump
 1033              	.LCB877:
 461:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     { 
 462:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 1034              		.loc 1 462 33
 1035 04ee 7B68     		ldr	r3, [r7, #4]
 1036 04f0 1B6A     		ldr	r3, [r3, #32]
 1037              		.loc 1 462 9
 1038 04f2 022B     		cmp	r3, #2
 1039 04f4 4CD1     		bne	.L65
 463:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 464:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the parameters */
 465:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 466:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PLL_MUL(RCC_OscInitStruct->PLL.PLLMUL));
 467:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_RCC_PREDIV(RCC_OscInitStruct->PLL.PREDIV));
 468:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 469:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the main PLL. */
 470:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_DISABLE();
 1040              		.loc 1 470 9
 1041 04f6 374B     		ldr	r3, .L75
 1042 04f8 1A68     		ldr	r2, [r3]
 1043 04fa 364B     		ldr	r3, .L75
 1044 04fc 3849     		ldr	r1, .L75+12
 1045 04fe 0A40     		ands	r2, r1
 1046 0500 1A60     		str	r2, [r3]
 471:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 472:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 473:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1047              		.loc 1 473 21
 1048 0502 FFF7FEFF 		bl	HAL_GetTick
 1049 0506 0300     		movs	r3, r0
 1050 0508 3B61     		str	r3, [r7, #16]
 474:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 475:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is disabled */
 476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 1051              		.loc 1 476 14
 1052 050a 08E0     		b	.L66
 1053              	.L67:
 477:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 478:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 1054              		.loc 1 478 15
 1055 050c FFF7FEFF 		bl	HAL_GetTick
 1056 0510 0200     		movs	r2, r0
 1057              		.loc 1 478 29
 1058 0512 3B69     		ldr	r3, [r7, #16]
 1059 0514 D31A     		subs	r3, r2, r3
 1060              		.loc 1 478 13
 1061 0516 022B     		cmp	r3, #2
 1062 0518 01D9     		bls	.L66
 479:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 480:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1063              		.loc 1 480 20
 1064 051a 0323     		movs	r3, #3
 1065 051c 56E0     		b	.L16
 1066              	.L66:
 476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1067              		.loc 1 476 15
 1068 051e 2D4B     		ldr	r3, .L75
 1069 0520 1A68     		ldr	r2, [r3]
 1070 0522 8023     		movs	r3, #128
 1071 0524 9B04     		lsls	r3, r3, #18
 1072 0526 1340     		ands	r3, r2
 476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1073              		.loc 1 476 52
 1074 0528 F0D1     		bne	.L67
 481:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 482:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 483:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 484:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the main PLL clock source, predivider and multiplication factor. */
 485:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 1075              		.loc 1 485 9
 1076 052a 2A4B     		ldr	r3, .L75
 1077 052c DB6A     		ldr	r3, [r3, #44]
 1078 052e 0F22     		movs	r2, #15
 1079 0530 9343     		bics	r3, r2
 1080 0532 1900     		movs	r1, r3
 1081 0534 7B68     		ldr	r3, [r7, #4]
 1082 0536 DA6A     		ldr	r2, [r3, #44]
 1083 0538 264B     		ldr	r3, .L75
 1084 053a 0A43     		orrs	r2, r1
 1085 053c DA62     		str	r2, [r3, #44]
 1086 053e 254B     		ldr	r3, .L75
 1087 0540 5B68     		ldr	r3, [r3, #4]
 1088 0542 284A     		ldr	r2, .L75+16
 1089 0544 1340     		ands	r3, r2
 1090 0546 1900     		movs	r1, r3
 1091 0548 7B68     		ldr	r3, [r7, #4]
 1092 054a 9A6A     		ldr	r2, [r3, #40]
 1093 054c 7B68     		ldr	r3, [r7, #4]
 1094 054e 5B6A     		ldr	r3, [r3, #36]
 1095 0550 1A43     		orrs	r2, r3
 1096 0552 204B     		ldr	r3, .L75
 1097 0554 0A43     		orrs	r2, r1
 1098 0556 5A60     		str	r2, [r3, #4]
 486:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                              RCC_OscInitStruct->PLL.PREDIV,
 487:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                              RCC_OscInitStruct->PLL.PLLMUL);
 488:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable the main PLL. */
 489:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_ENABLE();
 1099              		.loc 1 489 9
 1100 0558 1E4B     		ldr	r3, .L75
 1101 055a 1A68     		ldr	r2, [r3]
 1102 055c 1D4B     		ldr	r3, .L75
 1103 055e 8021     		movs	r1, #128
 1104 0560 4904     		lsls	r1, r1, #17
 1105 0562 0A43     		orrs	r2, r1
 1106 0564 1A60     		str	r2, [r3]
 490:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 491:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 492:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1107              		.loc 1 492 21
 1108 0566 FFF7FEFF 		bl	HAL_GetTick
 1109 056a 0300     		movs	r3, r0
 1110 056c 3B61     		str	r3, [r7, #16]
 493:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 494:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is ready */
 495:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 1111              		.loc 1 495 14
 1112 056e 08E0     		b	.L68
 1113              	.L69:
 496:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 497:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 1114              		.loc 1 497 15
 1115 0570 FFF7FEFF 		bl	HAL_GetTick
 1116 0574 0200     		movs	r2, r0
 1117              		.loc 1 497 29
 1118 0576 3B69     		ldr	r3, [r7, #16]
 1119 0578 D31A     		subs	r3, r2, r3
 1120              		.loc 1 497 13
 1121 057a 022B     		cmp	r3, #2
 1122 057c 01D9     		bls	.L68
 498:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 499:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1123              		.loc 1 499 20
 1124 057e 0323     		movs	r3, #3
 1125 0580 24E0     		b	.L16
 1126              	.L68:
 495:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1127              		.loc 1 495 15
 1128 0582 144B     		ldr	r3, .L75
 1129 0584 1A68     		ldr	r2, [r3]
 1130 0586 8023     		movs	r3, #128
 1131 0588 9B04     		lsls	r3, r3, #18
 1132 058a 1340     		ands	r3, r2
 495:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1133              		.loc 1 495 52
 1134 058c F0D0     		beq	.L69
 1135 058e 1CE0     		b	.L63
 1136              	.L65:
 500:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 501:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 502:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 503:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
 504:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 505:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable the main PLL. */
 506:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_PLL_DISABLE();
 1137              		.loc 1 506 9
 1138 0590 104B     		ldr	r3, .L75
 1139 0592 1A68     		ldr	r2, [r3]
 1140 0594 0F4B     		ldr	r3, .L75
 1141 0596 1249     		ldr	r1, .L75+12
 1142 0598 0A40     		ands	r2, r1
 1143 059a 1A60     		str	r2, [r3]
 507:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  
 508:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 509:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1144              		.loc 1 509 21
 1145 059c FFF7FEFF 		bl	HAL_GetTick
 1146 05a0 0300     		movs	r3, r0
 1147 05a2 3B61     		str	r3, [r7, #16]
 510:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 511:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till PLL is disabled */  
 512:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 1148              		.loc 1 512 14
 1149 05a4 08E0     		b	.L70
 1150              	.L71:
 513:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 514:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 1151              		.loc 1 514 15
 1152 05a6 FFF7FEFF 		bl	HAL_GetTick
 1153 05aa 0200     		movs	r2, r0
 1154              		.loc 1 514 29
 1155 05ac 3B69     		ldr	r3, [r7, #16]
 1156 05ae D31A     		subs	r3, r2, r3
 1157              		.loc 1 514 13
 1158 05b0 022B     		cmp	r3, #2
 1159 05b2 01D9     		bls	.L70
 515:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 516:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1160              		.loc 1 516 20
 1161 05b4 0323     		movs	r3, #3
 1162 05b6 09E0     		b	.L16
 1163              	.L70:
 512:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1164              		.loc 1 512 15
 1165 05b8 064B     		ldr	r3, .L75
 1166 05ba 1A68     		ldr	r2, [r3]
 1167 05bc 8023     		movs	r3, #128
 1168 05be 9B04     		lsls	r3, r3, #18
 1169 05c0 1340     		ands	r3, r2
 512:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1170              		.loc 1 512 52
 1171 05c2 F0D1     		bne	.L71
 1172 05c4 01E0     		b	.L63
 1173              	.L64:
 517:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 518:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 519:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 520:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 521:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 522:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 523:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1174              		.loc 1 523 14
 1175 05c6 0123     		movs	r3, #1
 1176 05c8 00E0     		b	.L16
 1177              	.L63:
 524:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 525:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 526:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 527:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1178              		.loc 1 527 10
 1179 05ca 0023     		movs	r3, #0
 1180              	.L16:
 528:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1181              		.loc 1 528 1
 1182 05cc 1800     		movs	r0, r3
 1183 05ce BD46     		mov	sp, r7
 1184 05d0 06B0     		add	sp, sp, #24
 1185              		@ sp needed
 1186 05d2 80BD     		pop	{r7, pc}
 1187              	.L76:
 1188              		.align	2
 1189              	.L75:
 1190 05d4 00100240 		.word	1073876992
 1191 05d8 88130000 		.word	5000
 1192 05dc FFFFFFEF 		.word	-268435457
 1193 05e0 FFFFFFFE 		.word	-16777217
 1194 05e4 FFFFC2FF 		.word	-3997697
 1195              		.cfi_endproc
 1196              	.LFE41:
 1198              		.section	.text.HAL_RCC_ClockConfig,"ax",%progbits
 1199              		.align	1
 1200              		.global	HAL_RCC_ClockConfig
 1201              		.syntax unified
 1202              		.code	16
 1203              		.thumb_func
 1204              		.fpu softvfp
 1206              	HAL_RCC_ClockConfig:
 1207              	.LFB42:
 529:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 530:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
 531:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initializes the CPU, AHB and APB buses clocks according to the specified 
 532:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         parameters in the RCC_ClkInitStruct.
 533:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  RCC_ClkInitStruct pointer to an RCC_OscInitTypeDef structure that
 534:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         contains the configuration information for the RCC peripheral.
 535:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  FLatency FLASH Latency                   
 536:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          The value of this parameter depend on device used within the same series
 537:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency 
 538:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         and updated by @ref HAL_RCC_GetHCLKFreq() function called within this function
 539:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
 540:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   The HSI is used (enabled by hardware) as system clock source after
 541:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         start-up from Reset, wake-up from STOP and STANDBY mode, or in case
 542:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         of failure of the HSE used directly or indirectly as system clock
 543:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (if the Clock Security System CSS is enabled).
 544:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *           
 545:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   A switch from one clock source to another occurs only if the target
 546:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         clock source is ready (clock stable after start-up delay or PLL locked). 
 547:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         If a clock source which is not yet ready is selected, the switch will
 548:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         occur when the clock source will be ready. 
 549:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         You can use @ref HAL_RCC_GetClockConfig() function to know which clock is
 550:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         currently used as system clock source.
 551:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
 552:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
 553:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
 554:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 1208              		.loc 1 554 1
 1209              		.cfi_startproc
 1210              		@ args = 0, pretend = 0, frame = 16
 1211              		@ frame_needed = 1, uses_anonymous_args = 0
 1212 0000 80B5     		push	{r7, lr}
 1213              	.LCFI11:
 1214              		.cfi_def_cfa_offset 8
 1215              		.cfi_offset 7, -8
 1216              		.cfi_offset 14, -4
 1217 0002 84B0     		sub	sp, sp, #16
 1218              	.LCFI12:
 1219              		.cfi_def_cfa_offset 24
 1220 0004 00AF     		add	r7, sp, #0
 1221              	.LCFI13:
 1222              		.cfi_def_cfa_register 7
 1223 0006 7860     		str	r0, [r7, #4]
 1224 0008 3960     		str	r1, [r7]
 555:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 1225              		.loc 1 555 12
 1226 000a 0023     		movs	r3, #0
 1227 000c FB60     		str	r3, [r7, #12]
 556:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 557:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 558:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(RCC_ClkInitStruct != NULL);
 559:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 560:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_FLASH_LATENCY(FLatency));
 561:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 562:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
 563:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   must be correctly programmed according to the frequency of the CPU clock 
 564:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     (HCLK) of the device. */
 565:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 566:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Increasing the number of wait states because of higher CPU frequency */
 567:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 1228              		.loc 1 567 23
 1229 000e 634B     		ldr	r3, .L95
 1230 0010 1B68     		ldr	r3, [r3]
 1231              		.loc 1 567 29
 1232 0012 0122     		movs	r2, #1
 1233 0014 1340     		ands	r3, r2
 1234              		.loc 1 567 5
 1235 0016 3A68     		ldr	r2, [r7]
 1236 0018 9A42     		cmp	r2, r3
 1237 001a 11D9     		bls	.L78
 568:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 569:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 570:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 1238              		.loc 1 570 5
 1239 001c 5F4B     		ldr	r3, .L95
 1240 001e 1B68     		ldr	r3, [r3]
 1241 0020 0122     		movs	r2, #1
 1242 0022 9343     		bics	r3, r2
 1243 0024 1900     		movs	r1, r3
 1244 0026 5D4B     		ldr	r3, .L95
 1245 0028 3A68     		ldr	r2, [r7]
 1246 002a 0A43     		orrs	r2, r1
 1247 002c 1A60     		str	r2, [r3]
 571:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 572:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 573:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     memory by reading the FLASH_ACR register */
 574:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 1248              		.loc 1 574 14
 1249 002e 5B4B     		ldr	r3, .L95
 1250 0030 1B68     		ldr	r3, [r3]
 1251              		.loc 1 574 20
 1252 0032 0122     		movs	r2, #1
 1253 0034 1340     		ands	r3, r2
 1254              		.loc 1 574 7
 1255 0036 3A68     		ldr	r2, [r7]
 1256 0038 9A42     		cmp	r2, r3
 1257 003a 01D0     		beq	.L78
 575:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 576:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1258              		.loc 1 576 14
 1259 003c 0123     		movs	r3, #1
 1260 003e A9E0     		b	.L79
 1261              	.L78:
 577:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 578:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 579:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 580:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- HCLK Configuration --------------------------*/
 581:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 1262              		.loc 1 581 25
 1263 0040 7B68     		ldr	r3, [r7, #4]
 1264 0042 1B68     		ldr	r3, [r3]
 1265              		.loc 1 581 38
 1266 0044 0222     		movs	r2, #2
 1267 0046 1340     		ands	r3, r2
 1268              		.loc 1 581 5
 1269 0048 09D0     		beq	.L80
 582:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 583:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 584:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 1270              		.loc 1 584 5
 1271 004a 554B     		ldr	r3, .L95+4
 1272 004c 5B68     		ldr	r3, [r3, #4]
 1273 004e F022     		movs	r2, #240
 1274 0050 9343     		bics	r3, r2
 1275 0052 1900     		movs	r1, r3
 1276 0054 7B68     		ldr	r3, [r7, #4]
 1277 0056 9A68     		ldr	r2, [r3, #8]
 1278 0058 514B     		ldr	r3, .L95+4
 1279 005a 0A43     		orrs	r2, r1
 1280 005c 5A60     		str	r2, [r3, #4]
 1281              	.L80:
 585:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 586:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 587:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------- SYSCLK Configuration ---------------------------*/ 
 588:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 1282              		.loc 1 588 25
 1283 005e 7B68     		ldr	r3, [r7, #4]
 1284 0060 1B68     		ldr	r3, [r3]
 1285              		.loc 1 588 38
 1286 0062 0122     		movs	r2, #1
 1287 0064 1340     		ands	r3, r2
 1288              		.loc 1 588 5
 1289 0066 00D1     		bne	.LCB1106
 1290 0068 67E0     		b	.L81	@long jump
 1291              	.LCB1106:
 589:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 590:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 591:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 592:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSE is selected as System Clock Source */
 593:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 1292              		.loc 1 593 25
 1293 006a 7B68     		ldr	r3, [r7, #4]
 1294 006c 5B68     		ldr	r3, [r3, #4]
 1295              		.loc 1 593 7
 1296 006e 012B     		cmp	r3, #1
 1297 0070 07D1     		bne	.L82
 594:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 595:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSE ready flag */  
 596:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 1298              		.loc 1 596 10
 1299 0072 4B4B     		ldr	r3, .L95+4
 1300 0074 1A68     		ldr	r2, [r3]
 1301 0076 8023     		movs	r3, #128
 1302 0078 9B02     		lsls	r3, r3, #10
 1303 007a 1340     		ands	r3, r2
 1304              		.loc 1 596 9
 1305 007c 14D1     		bne	.L83
 597:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 598:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1306              		.loc 1 598 16
 1307 007e 0123     		movs	r3, #1
 1308 0080 88E0     		b	.L79
 1309              	.L82:
 599:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 600:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 601:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* PLL is selected as System Clock Source */
 602:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 1310              		.loc 1 602 30
 1311 0082 7B68     		ldr	r3, [r7, #4]
 1312 0084 5B68     		ldr	r3, [r3, #4]
 1313              		.loc 1 602 12
 1314 0086 022B     		cmp	r3, #2
 1315 0088 07D1     		bne	.L84
 603:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 604:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the PLL ready flag */  
 605:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 1316              		.loc 1 605 10
 1317 008a 454B     		ldr	r3, .L95+4
 1318 008c 1A68     		ldr	r2, [r3]
 1319 008e 8023     		movs	r3, #128
 1320 0090 9B04     		lsls	r3, r3, #18
 1321 0092 1340     		ands	r3, r2
 1322              		.loc 1 605 9
 1323 0094 08D1     		bne	.L83
 606:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 607:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1324              		.loc 1 607 16
 1325 0096 0123     		movs	r3, #1
 1326 0098 7CE0     		b	.L79
 1327              	.L84:
 608:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 609:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 610:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_CFGR_SWS_HSI48)
 611:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSI48 is selected as System Clock Source */
 612:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 613:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 614:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI48 ready flag */
 615:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == RESET)
 616:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 617:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 618:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 619:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 620:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_CFGR_SWS_HSI48 */
 621:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* HSI is selected as System Clock Source */
 622:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 623:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 624:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Check the HSI ready flag */  
 625:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 1328              		.loc 1 625 10
 1329 009a 414B     		ldr	r3, .L95+4
 1330 009c 1B68     		ldr	r3, [r3]
 1331 009e 0222     		movs	r2, #2
 1332 00a0 1340     		ands	r3, r2
 1333              		.loc 1 625 9
 1334 00a2 01D1     		bne	.L83
 626:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 627:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_ERROR;
 1335              		.loc 1 627 16
 1336 00a4 0123     		movs	r3, #1
 1337 00a6 75E0     		b	.L79
 1338              	.L83:
 628:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 629:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 630:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 1339              		.loc 1 630 5
 1340 00a8 3D4B     		ldr	r3, .L95+4
 1341 00aa 5B68     		ldr	r3, [r3, #4]
 1342 00ac 0322     		movs	r2, #3
 1343 00ae 9343     		bics	r3, r2
 1344 00b0 1900     		movs	r1, r3
 1345 00b2 7B68     		ldr	r3, [r7, #4]
 1346 00b4 5A68     		ldr	r2, [r3, #4]
 1347 00b6 3A4B     		ldr	r3, .L95+4
 1348 00b8 0A43     		orrs	r2, r1
 1349 00ba 5A60     		str	r2, [r3, #4]
 631:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 632:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Get Start Tick */
 633:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 1350              		.loc 1 633 17
 1351 00bc FFF7FEFF 		bl	HAL_GetTick
 1352 00c0 0300     		movs	r3, r0
 1353 00c2 FB60     		str	r3, [r7, #12]
 634:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 635:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 1354              		.loc 1 635 25
 1355 00c4 7B68     		ldr	r3, [r7, #4]
 1356 00c6 5B68     		ldr	r3, [r3, #4]
 1357              		.loc 1 635 7
 1358 00c8 012B     		cmp	r3, #1
 1359 00ca 11D1     		bne	.L85
 636:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 637:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 1360              		.loc 1 637 13
 1361 00cc 09E0     		b	.L86
 1362              	.L87:
 638:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 639:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1363              		.loc 1 639 13
 1364 00ce FFF7FEFF 		bl	HAL_GetTick
 1365 00d2 0200     		movs	r2, r0
 1366              		.loc 1 639 27
 1367 00d4 FB68     		ldr	r3, [r7, #12]
 1368 00d6 D31A     		subs	r3, r2, r3
 1369              		.loc 1 639 11
 1370 00d8 324A     		ldr	r2, .L95+8
 1371 00da 9342     		cmp	r3, r2
 1372 00dc 01D9     		bls	.L86
 640:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 641:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1373              		.loc 1 641 18
 1374 00de 0323     		movs	r3, #3
 1375 00e0 58E0     		b	.L79
 1376              	.L86:
 637:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1377              		.loc 1 637 14
 1378 00e2 2F4B     		ldr	r3, .L95+4
 1379 00e4 5B68     		ldr	r3, [r3, #4]
 1380 00e6 0C22     		movs	r2, #12
 1381 00e8 1340     		ands	r3, r2
 637:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1382              		.loc 1 637 44
 1383 00ea 042B     		cmp	r3, #4
 1384 00ec EFD1     		bne	.L87
 1385 00ee 24E0     		b	.L81
 1386              	.L85:
 642:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 643:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 644:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 645:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 1387              		.loc 1 645 30
 1388 00f0 7B68     		ldr	r3, [r7, #4]
 1389 00f2 5B68     		ldr	r3, [r3, #4]
 1390              		.loc 1 645 12
 1391 00f4 022B     		cmp	r3, #2
 1392 00f6 1BD1     		bne	.L91
 646:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 647:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 1393              		.loc 1 647 13
 1394 00f8 09E0     		b	.L89
 1395              	.L90:
 648:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 649:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1396              		.loc 1 649 13
 1397 00fa FFF7FEFF 		bl	HAL_GetTick
 1398 00fe 0200     		movs	r2, r0
 1399              		.loc 1 649 27
 1400 0100 FB68     		ldr	r3, [r7, #12]
 1401 0102 D31A     		subs	r3, r2, r3
 1402              		.loc 1 649 11
 1403 0104 274A     		ldr	r2, .L95+8
 1404 0106 9342     		cmp	r3, r2
 1405 0108 01D9     		bls	.L89
 650:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 651:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1406              		.loc 1 651 18
 1407 010a 0323     		movs	r3, #3
 1408 010c 42E0     		b	.L79
 1409              	.L89:
 647:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1410              		.loc 1 647 14
 1411 010e 244B     		ldr	r3, .L95+4
 1412 0110 5B68     		ldr	r3, [r3, #4]
 1413 0112 0C22     		movs	r2, #12
 1414 0114 1340     		ands	r3, r2
 647:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1415              		.loc 1 647 44
 1416 0116 082B     		cmp	r3, #8
 1417 0118 EFD1     		bne	.L90
 1418 011a 0EE0     		b	.L81
 1419              	.L92:
 652:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 653:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 654:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 655:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(RCC_CFGR_SWS_HSI48)
 656:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI48)
 657:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 658:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI48)
 659:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 660:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 661:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 662:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 663:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 664:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 665:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 666:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* RCC_CFGR_SWS_HSI48 */
 667:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     else
 668:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 669:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 670:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 671:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 1420              		.loc 1 671 13
 1421 011c FFF7FEFF 		bl	HAL_GetTick
 1422 0120 0200     		movs	r2, r0
 1423              		.loc 1 671 27
 1424 0122 FB68     		ldr	r3, [r7, #12]
 1425 0124 D31A     		subs	r3, r2, r3
 1426              		.loc 1 671 11
 1427 0126 1F4A     		ldr	r2, .L95+8
 1428 0128 9342     		cmp	r3, r2
 1429 012a 01D9     		bls	.L91
 672:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 673:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1430              		.loc 1 673 18
 1431 012c 0323     		movs	r3, #3
 1432 012e 31E0     		b	.L79
 1433              	.L91:
 669:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1434              		.loc 1 669 14
 1435 0130 1B4B     		ldr	r3, .L95+4
 1436 0132 5B68     		ldr	r3, [r3, #4]
 1437 0134 0C22     		movs	r2, #12
 1438 0136 1340     		ands	r3, r2
 669:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1439              		.loc 1 669 44
 1440 0138 F0D1     		bne	.L92
 1441              	.L81:
 674:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 675:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 676:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }      
 677:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }    
 678:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Decreasing the number of wait states because of lower CPU frequency */
 679:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 1442              		.loc 1 679 23
 1443 013a 184B     		ldr	r3, .L95
 1444 013c 1B68     		ldr	r3, [r3]
 1445              		.loc 1 679 29
 1446 013e 0122     		movs	r2, #1
 1447 0140 1340     		ands	r3, r2
 1448              		.loc 1 679 5
 1449 0142 3A68     		ldr	r2, [r7]
 1450 0144 9A42     		cmp	r2, r3
 1451 0146 11D2     		bcs	.L93
 680:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {    
 681:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
 682:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_FLASH_SET_LATENCY(FLatency);
 1452              		.loc 1 682 5
 1453 0148 144B     		ldr	r3, .L95
 1454 014a 1B68     		ldr	r3, [r3]
 1455 014c 0122     		movs	r2, #1
 1456 014e 9343     		bics	r3, r2
 1457 0150 1900     		movs	r1, r3
 1458 0152 124B     		ldr	r3, .L95
 1459 0154 3A68     		ldr	r2, [r7]
 1460 0156 0A43     		orrs	r2, r1
 1461 0158 1A60     		str	r2, [r3]
 683:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 684:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check that the new number of wait states is taken into account to access the Flash
 685:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     memory by reading the FLASH_ACR register */
 686:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 1462              		.loc 1 686 14
 1463 015a 104B     		ldr	r3, .L95
 1464 015c 1B68     		ldr	r3, [r3]
 1465              		.loc 1 686 20
 1466 015e 0122     		movs	r2, #1
 1467 0160 1340     		ands	r3, r2
 1468              		.loc 1 686 7
 1469 0162 3A68     		ldr	r2, [r7]
 1470 0164 9A42     		cmp	r2, r3
 1471 0166 01D0     		beq	.L93
 687:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 688:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_ERROR;
 1472              		.loc 1 688 14
 1473 0168 0123     		movs	r3, #1
 1474 016a 13E0     		b	.L79
 1475              	.L93:
 689:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 690:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }    
 691:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 692:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- PCLK1 Configuration ---------------------------*/ 
 693:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 1476              		.loc 1 693 25
 1477 016c 7B68     		ldr	r3, [r7, #4]
 1478 016e 1B68     		ldr	r3, [r3]
 1479              		.loc 1 693 38
 1480 0170 0422     		movs	r2, #4
 1481 0172 1340     		ands	r3, r2
 1482              		.loc 1 693 5
 1483 0174 09D0     		beq	.L94
 694:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 695:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
 696:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 1484              		.loc 1 696 5
 1485 0176 0A4B     		ldr	r3, .L95+4
 1486 0178 5B68     		ldr	r3, [r3, #4]
 1487 017a 0B4A     		ldr	r2, .L95+12
 1488 017c 1340     		ands	r3, r2
 1489 017e 1900     		movs	r1, r3
 1490 0180 7B68     		ldr	r3, [r7, #4]
 1491 0182 DA68     		ldr	r2, [r3, #12]
 1492 0184 064B     		ldr	r3, .L95+4
 1493 0186 0A43     		orrs	r2, r1
 1494 0188 5A60     		str	r2, [r3, #4]
 1495              	.L94:
 697:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 698:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 699:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Update the SystemCoreClock global variable */
 700:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_
 701:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   SystemCoreClock = 7372800;
 1496              		.loc 1 701 19
 1497 018a 084B     		ldr	r3, .L95+16
 1498 018c E122     		movs	r2, #225
 1499 018e D203     		lsls	r2, r2, #15
 1500 0190 1A60     		str	r2, [r3]
 702:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 703:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the source of time base considering new system clocks settings*/
 704:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   //HAL_InitTick (TICK_INT_PRIORITY);
 705:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 706:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1501              		.loc 1 706 10
 1502 0192 0023     		movs	r3, #0
 1503              	.L79:
 707:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1504              		.loc 1 707 1
 1505 0194 1800     		movs	r0, r3
 1506 0196 BD46     		mov	sp, r7
 1507 0198 04B0     		add	sp, sp, #16
 1508              		@ sp needed
 1509 019a 80BD     		pop	{r7, pc}
 1510              	.L96:
 1511              		.align	2
 1512              	.L95:
 1513 019c 00200240 		.word	1073881088
 1514 01a0 00100240 		.word	1073876992
 1515 01a4 88130000 		.word	5000
 1516 01a8 FFF8FFFF 		.word	-1793
 1517 01ac 00000000 		.word	SystemCoreClock
 1518              		.cfi_endproc
 1519              	.LFE42:
 1521              		.section	.text.HAL_RCCEx_PeriphCLKConfig,"ax",%progbits
 1522              		.align	1
 1523              		.global	HAL_RCCEx_PeriphCLKConfig
 1524              		.syntax unified
 1525              		.code	16
 1526              		.thumb_func
 1527              		.fpu softvfp
 1529              	HAL_RCCEx_PeriphCLKConfig:
 1530              	.LFB43:
 708:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 709:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
 710:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 1531              		.loc 1 710 1
 1532              		.cfi_startproc
 1533              		@ args = 0, pretend = 0, frame = 24
 1534              		@ frame_needed = 1, uses_anonymous_args = 0
 1535 0000 80B5     		push	{r7, lr}
 1536              	.LCFI14:
 1537              		.cfi_def_cfa_offset 8
 1538              		.cfi_offset 7, -8
 1539              		.cfi_offset 14, -4
 1540 0002 86B0     		sub	sp, sp, #24
 1541              	.LCFI15:
 1542              		.cfi_def_cfa_offset 32
 1543 0004 00AF     		add	r7, sp, #0
 1544              	.LCFI16:
 1545              		.cfi_def_cfa_register 7
 1546 0006 7860     		str	r0, [r7, #4]
 711:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 1547              		.loc 1 711 12
 1548 0008 0023     		movs	r3, #0
 1549 000a 3B61     		str	r3, [r7, #16]
 712:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t temp_reg = 0U;
 1550              		.loc 1 712 12
 1551 000c 0023     		movs	r3, #0
 1552 000e FB60     		str	r3, [r7, #12]
 713:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 714:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 715:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
 716:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 717:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*---------------------------- RTC configuration -------------------------------*/
 718:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 1553              		.loc 1 718 21
 1554 0010 7B68     		ldr	r3, [r7, #4]
 1555 0012 1A68     		ldr	r2, [r3]
 1556              		.loc 1 718 45
 1557 0014 8023     		movs	r3, #128
 1558 0016 5B02     		lsls	r3, r3, #9
 1559 0018 1340     		ands	r3, r2
 1560              		.loc 1 718 5
 1561 001a 00D1     		bne	.LCB1342
 1562 001c 8EE0     		b	.L98	@long jump
 1563              	.LCB1342:
 1564              	.LBB4:
 719:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 720:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* check for RTC Parameters used to output RTCCLK */
 721:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 722:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 723:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     FlagStatus       pwrclkchanged = RESET;
 1565              		.loc 1 723 22
 1566 001e 1720     		movs	r0, #23
 1567 0020 3B18     		adds	r3, r7, r0
 1568 0022 0022     		movs	r2, #0
 1569 0024 1A70     		strb	r2, [r3]
 724:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 725:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* As soon as function is called to change RTC clock source, activation of the 
 726:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        power domain is done. */
 727:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Requires to enable write access to Backup Domain of necessary */
 728:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 1570              		.loc 1 728 8
 1571 0026 574B     		ldr	r3, .L109
 1572 0028 DA69     		ldr	r2, [r3, #28]
 1573 002a 8023     		movs	r3, #128
 1574 002c 5B05     		lsls	r3, r3, #21
 1575 002e 1340     		ands	r3, r2
 1576              		.loc 1 728 7
 1577 0030 10D1     		bne	.L99
 1578              	.LBB5:
 729:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 730:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_PWR_CLK_ENABLE();
 1579              		.loc 1 730 5
 1580 0032 544B     		ldr	r3, .L109
 1581 0034 DA69     		ldr	r2, [r3, #28]
 1582 0036 534B     		ldr	r3, .L109
 1583 0038 8021     		movs	r1, #128
 1584 003a 4905     		lsls	r1, r1, #21
 1585 003c 0A43     		orrs	r2, r1
 1586 003e DA61     		str	r2, [r3, #28]
 1587 0040 504B     		ldr	r3, .L109
 1588 0042 DA69     		ldr	r2, [r3, #28]
 1589 0044 8023     		movs	r3, #128
 1590 0046 5B05     		lsls	r3, r3, #21
 1591 0048 1340     		ands	r3, r2
 1592 004a BB60     		str	r3, [r7, #8]
 1593 004c BB68     		ldr	r3, [r7, #8]
 1594              	.LBE5:
 731:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       pwrclkchanged = SET;
 1595              		.loc 1 731 21
 1596 004e 3B18     		adds	r3, r7, r0
 1597 0050 0122     		movs	r2, #1
 1598 0052 1A70     		strb	r2, [r3]
 1599              	.L99:
 732:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 733:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 734:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 1600              		.loc 1 734 8
 1601 0054 4C4B     		ldr	r3, .L109+4
 1602 0056 1A68     		ldr	r2, [r3]
 1603 0058 8023     		movs	r3, #128
 1604 005a 5B00     		lsls	r3, r3, #1
 1605 005c 1340     		ands	r3, r2
 1606              		.loc 1 734 7
 1607 005e 1AD1     		bne	.L100
 735:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 736:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Enable write access to Backup domain */
 737:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(PWR->CR, PWR_CR_DBP);
 1608              		.loc 1 737 7
 1609 0060 494B     		ldr	r3, .L109+4
 1610 0062 1A68     		ldr	r2, [r3]
 1611 0064 484B     		ldr	r3, .L109+4
 1612 0066 8021     		movs	r1, #128
 1613 0068 4900     		lsls	r1, r1, #1
 1614 006a 0A43     		orrs	r2, r1
 1615 006c 1A60     		str	r2, [r3]
 738:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 739:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for Backup domain Write protection disable */
 740:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       tickstart = HAL_GetTick();
 1616              		.loc 1 740 19
 1617 006e FFF7FEFF 		bl	HAL_GetTick
 1618 0072 0300     		movs	r3, r0
 1619 0074 3B61     		str	r3, [r7, #16]
 741:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 742:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 1620              		.loc 1 742 12
 1621 0076 08E0     		b	.L101
 1622              	.L103:
 743:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 744:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 1623              		.loc 1 744 13
 1624 0078 FFF7FEFF 		bl	HAL_GetTick
 1625 007c 0200     		movs	r2, r0
 1626              		.loc 1 744 27
 1627 007e 3B69     		ldr	r3, [r7, #16]
 1628 0080 D31A     		subs	r3, r2, r3
 1629              		.loc 1 744 11
 1630 0082 642B     		cmp	r3, #100
 1631 0084 01D9     		bls	.L101
 745:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 746:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           return HAL_TIMEOUT;
 1632              		.loc 1 746 18
 1633 0086 0323     		movs	r3, #3
 1634 0088 77E0     		b	.L102
 1635              	.L101:
 742:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 1636              		.loc 1 742 13
 1637 008a 3F4B     		ldr	r3, .L109+4
 1638 008c 1A68     		ldr	r2, [r3]
 1639 008e 8023     		movs	r3, #128
 1640 0090 5B00     		lsls	r3, r3, #1
 1641 0092 1340     		ands	r3, r2
 1642 0094 F0D0     		beq	.L103
 1643              	.L100:
 747:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 748:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 749:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 750:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 751:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value 
 752:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 1644              		.loc 1 752 20
 1645 0096 3B4B     		ldr	r3, .L109
 1646 0098 1A6A     		ldr	r2, [r3, #32]
 1647              		.loc 1 752 14
 1648 009a C023     		movs	r3, #192
 1649 009c 9B00     		lsls	r3, r3, #2
 1650 009e 1340     		ands	r3, r2
 1651 00a0 FB60     		str	r3, [r7, #12]
 753:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSE
 1652              		.loc 1 753 7
 1653 00a2 FB68     		ldr	r3, [r7, #12]
 1654 00a4 002B     		cmp	r3, #0
 1655 00a6 34D0     		beq	.L104
 1656              		.loc 1 753 64 discriminator 1
 1657 00a8 7B68     		ldr	r3, [r7, #4]
 1658 00aa 5A68     		ldr	r2, [r3, #4]
 1659              		.loc 1 753 84 discriminator 1
 1660 00ac C023     		movs	r3, #192
 1661 00ae 9B00     		lsls	r3, r3, #2
 1662 00b0 1340     		ands	r3, r2
 1663              		.loc 1 753 34 discriminator 1
 1664 00b2 FA68     		ldr	r2, [r7, #12]
 1665 00b4 9A42     		cmp	r2, r3
 1666 00b6 2CD0     		beq	.L104
 754:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 755:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Store the content of BDCR register before the reset of Backup Domain */
 756:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 1667              		.loc 1 756 22
 1668 00b8 324B     		ldr	r3, .L109
 1669 00ba 1B6A     		ldr	r3, [r3, #32]
 1670              		.loc 1 756 16
 1671 00bc 334A     		ldr	r2, .L109+8
 1672 00be 1340     		ands	r3, r2
 1673 00c0 FB60     		str	r3, [r7, #12]
 757:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* RTC Clock selection can be changed only if the Backup Domain is reset */
 758:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_BACKUPRESET_FORCE();
 1674              		.loc 1 758 7
 1675 00c2 304B     		ldr	r3, .L109
 1676 00c4 1A6A     		ldr	r2, [r3, #32]
 1677 00c6 2F4B     		ldr	r3, .L109
 1678 00c8 8021     		movs	r1, #128
 1679 00ca 4902     		lsls	r1, r1, #9
 1680 00cc 0A43     		orrs	r2, r1
 1681 00ce 1A62     		str	r2, [r3, #32]
 759:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_BACKUPRESET_RELEASE();
 1682              		.loc 1 759 7
 1683 00d0 2C4B     		ldr	r3, .L109
 1684 00d2 1A6A     		ldr	r2, [r3, #32]
 1685 00d4 2B4B     		ldr	r3, .L109
 1686 00d6 2E49     		ldr	r1, .L109+12
 1687 00d8 0A40     		ands	r2, r1
 1688 00da 1A62     		str	r2, [r3, #32]
 760:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Restore the Content of BDCR register */
 761:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       RCC->BDCR = temp_reg;
 1689              		.loc 1 761 10
 1690 00dc 294B     		ldr	r3, .L109
 1691              		.loc 1 761 17
 1692 00de FA68     		ldr	r2, [r7, #12]
 1693 00e0 1A62     		str	r2, [r3, #32]
 762:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       
 763:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait for LSERDY if LSE was enabled */
 764:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 1694              		.loc 1 764 11
 1695 00e2 FB68     		ldr	r3, [r7, #12]
 1696 00e4 0122     		movs	r2, #1
 1697 00e6 1340     		ands	r3, r2
 1698              		.loc 1 764 10
 1699 00e8 13D0     		beq	.L104
 765:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 766:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Get Start Tick */
 767:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tickstart = HAL_GetTick();
 1700              		.loc 1 767 21
 1701 00ea FFF7FEFF 		bl	HAL_GetTick
 1702 00ee 0300     		movs	r3, r0
 1703 00f0 3B61     		str	r3, [r7, #16]
 768:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 769:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Wait till LSE is ready */  
 770:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 1704              		.loc 1 770 14
 1705 00f2 09E0     		b	.L105
 1706              	.L106:
 771:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 772:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 1707              		.loc 1 772 15
 1708 00f4 FFF7FEFF 		bl	HAL_GetTick
 1709 00f8 0200     		movs	r2, r0
 1710              		.loc 1 772 29
 1711 00fa 3B69     		ldr	r3, [r7, #16]
 1712 00fc D31A     		subs	r3, r2, r3
 1713              		.loc 1 772 13
 1714 00fe 254A     		ldr	r2, .L109+16
 1715 0100 9342     		cmp	r3, r2
 1716 0102 01D9     		bls	.L105
 773:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           {
 774:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****             return HAL_TIMEOUT;
 1717              		.loc 1 774 20
 1718 0104 0323     		movs	r3, #3
 1719 0106 38E0     		b	.L102
 1720              	.L105:
 770:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1721              		.loc 1 770 15
 1722 0108 1E4B     		ldr	r3, .L109
 1723 010a 1B6A     		ldr	r3, [r3, #32]
 1724 010c 0222     		movs	r2, #2
 1725 010e 1340     		ands	r3, r2
 770:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 1726              		.loc 1 770 51
 1727 0110 F0D0     		beq	.L106
 1728              	.L104:
 775:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           }
 776:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 777:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 778:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 779:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 1729              		.loc 1 779 5
 1730 0112 1C4B     		ldr	r3, .L109
 1731 0114 1B6A     		ldr	r3, [r3, #32]
 1732 0116 1D4A     		ldr	r2, .L109+8
 1733 0118 1340     		ands	r3, r2
 1734 011a 1900     		movs	r1, r3
 1735 011c 7B68     		ldr	r3, [r7, #4]
 1736 011e 5A68     		ldr	r2, [r3, #4]
 1737 0120 184B     		ldr	r3, .L109
 1738 0122 0A43     		orrs	r2, r1
 1739 0124 1A62     		str	r2, [r3, #32]
 780:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 781:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Require to disable power clock if necessary */
 782:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(pwrclkchanged == SET)
 1740              		.loc 1 782 7
 1741 0126 1723     		movs	r3, #23
 1742 0128 FB18     		adds	r3, r7, r3
 1743 012a 1B78     		ldrb	r3, [r3]
 1744 012c 012B     		cmp	r3, #1
 1745 012e 05D1     		bne	.L98
 783:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 784:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       __HAL_RCC_PWR_CLK_DISABLE();
 1746              		.loc 1 784 7
 1747 0130 144B     		ldr	r3, .L109
 1748 0132 DA69     		ldr	r2, [r3, #28]
 1749 0134 134B     		ldr	r3, .L109
 1750 0136 1849     		ldr	r1, .L109+20
 1751 0138 0A40     		ands	r2, r1
 1752 013a DA61     		str	r2, [r3, #28]
 1753              	.L98:
 1754              	.LBE4:
 785:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
 786:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 787:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 788:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------- USART1 Configuration ------------------------*/ 
 789:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 1755              		.loc 1 789 21
 1756 013c 7B68     		ldr	r3, [r7, #4]
 1757 013e 1B68     		ldr	r3, [r3]
 1758              		.loc 1 789 45
 1759 0140 0122     		movs	r2, #1
 1760 0142 1340     		ands	r3, r2
 1761              		.loc 1 789 5
 1762 0144 09D0     		beq	.L107
 790:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 791:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 792:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
 793:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 794:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART1 clock source */
 795:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 1763              		.loc 1 795 5
 1764 0146 0F4B     		ldr	r3, .L109
 1765 0148 1B6B     		ldr	r3, [r3, #48]
 1766 014a 0322     		movs	r2, #3
 1767 014c 9343     		bics	r3, r2
 1768 014e 1900     		movs	r1, r3
 1769 0150 7B68     		ldr	r3, [r7, #4]
 1770 0152 9A68     		ldr	r2, [r3, #8]
 1771 0154 0B4B     		ldr	r3, .L109
 1772 0156 0A43     		orrs	r2, r1
 1773 0158 1A63     		str	r2, [r3, #48]
 1774              	.L107:
 796:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 797:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 798:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 799:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F091xC) || defined(STM32F098xx)
 800:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- USART2 Configuration --------------------------*/ 
 801:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 802:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 803:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 804:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
 805:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 806:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART2 clock source */
 807:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 808:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 809:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F071xB || STM32F072xB || STM32F078xx || */
 810:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F091xC || STM32F098xx */
 811:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 812:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F091xC) || defined(STM32F098xx)
 813:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*----------------------------- USART3 Configuration --------------------------*/ 
 814:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 815:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 816:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 817:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
 818:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 819:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USART3 clock source */
 820:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 821:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 822:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F091xC || STM32F098xx */  
 823:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 824:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ I2C1 Configuration ------------------------*/ 
 825:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 1775              		.loc 1 825 21
 1776 015a 7B68     		ldr	r3, [r7, #4]
 1777 015c 1B68     		ldr	r3, [r3]
 1778              		.loc 1 825 45
 1779 015e 2022     		movs	r2, #32
 1780 0160 1340     		ands	r3, r2
 1781              		.loc 1 825 5
 1782 0162 09D0     		beq	.L108
 826:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 827:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 828:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
 829:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 830:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the I2C1 clock source */
 831:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 1783              		.loc 1 831 5
 1784 0164 074B     		ldr	r3, .L109
 1785 0166 1B6B     		ldr	r3, [r3, #48]
 1786 0168 1022     		movs	r2, #16
 1787 016a 9343     		bics	r3, r2
 1788 016c 1900     		movs	r1, r3
 1789 016e 7B68     		ldr	r3, [r7, #4]
 1790 0170 DA68     		ldr	r2, [r3, #12]
 1791 0172 044B     		ldr	r3, .L109
 1792 0174 0A43     		orrs	r2, r1
 1793 0176 1A63     		str	r2, [r3, #48]
 1794              	.L108:
 832:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 833:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 834:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F072xB) || defined(STM32F078xx) ||
 835:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ USB Configuration ------------------------*/ 
 836:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 837:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 838:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 839:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
 840:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 841:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the USB clock source */
 842:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 843:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 844:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F042x6 || STM32F048xx || STM32F072xB || STM32F078xx || STM32F070xB || STM32F070x6 */
 845:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 846:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined(STM32F042x6) || defined(STM32F048xx)\
 847:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F051x8) || defined(STM32F058xx)\
 848:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx)\
 849:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****  || defined(STM32F091xC) || defined(STM32F098xx)
 850:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*------------------------------ CEC clock Configuration -------------------*/ 
 851:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 852:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 853:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
 854:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
 855:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 856:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Configure the CEC clock source */
 857:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 858:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 859:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* STM32F042x6 || STM32F048xx ||                */
 860:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F051x8 || STM32F058xx ||                */
 861:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F071xB || STM32F072xB || STM32F078xx || */
 862:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        /* STM32F091xC || STM32F098xx */
 863:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 864:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 1795              		.loc 1 864 10
 1796 0178 0023     		movs	r3, #0
 1797              	.L102:
 865:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 1798              		.loc 1 865 1
 1799 017a 1800     		movs	r0, r3
 1800 017c BD46     		mov	sp, r7
 1801 017e 06B0     		add	sp, sp, #24
 1802              		@ sp needed
 1803 0180 80BD     		pop	{r7, pc}
 1804              	.L110:
 1805 0182 C046     		.align	2
 1806              	.L109:
 1807 0184 00100240 		.word	1073876992
 1808 0188 00700040 		.word	1073770496
 1809 018c FFFCFFFF 		.word	-769
 1810 0190 FFFFFEFF 		.word	-65537
 1811 0194 88130000 		.word	5000
 1812 0198 FFFFFFEF 		.word	-268435457
 1813              		.cfi_endproc
 1814              	.LFE43:
 1816              		.section	.text.HAL_GPIO_Init,"ax",%progbits
 1817              		.align	1
 1818              		.global	HAL_GPIO_Init
 1819              		.syntax unified
 1820              		.code	16
 1821              		.thumb_func
 1822              		.fpu softvfp
 1824              	HAL_GPIO_Init:
 1825              	.LFB44:
 866:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 867:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 868:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 869:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE             (0x00000003U)
 870:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define EXTI_MODE             (0x10000000U)
 871:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE_IT          (0x00010000U)
 872:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_MODE_EVT         (0x00020000U)
 873:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define RISING_EDGE           (0x00100000U)
 874:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define FALLING_EDGE          (0x00200000U)
 875:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_OUTPUT_TYPE      (0x00000010U)
 876:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 877:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define GPIO_NUMBER           (16U)
 878:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 879:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define __HAL_RCC_GPIOA_CLK_ENABLE()   do { \
 880:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         __IO uint32_t tmpreg; \
 881:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         SET_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
 882:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         /* Delay after an RCC peripheral clock enabling */\
 883:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         tmpreg = READ_BIT(RCC->AHBENR, RCC_AHBENR_GPIOAEN);\
 884:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         UNUSED(tmpreg); \
 885:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                       } while(0)
 886:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #define __HAL_RCC_USART1_CLK_ENABLE()   do { \
 887:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         __IO uint32_t tmpreg; \
 888:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
 889:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         /* Delay after an RCC peripheral clock enabling */\
 890:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);\
 891:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                         UNUSED(tmpreg); \
 892:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                                       } while(0)
 893:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 894:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
 895:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Initialize the GPIOx peripheral according to the specified parameters in the GPIO_Init.
 896:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIOx: where x can be (A..F) to select the GPIO peripheral for STM32F0 family
 897:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
 898:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         the configuration information for the specified GPIO peripheral.
 899:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval None
 900:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
 901:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
 902:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** { 
 1826              		.loc 1 902 1
 1827              		.cfi_startproc
 1828              		@ args = 0, pretend = 0, frame = 24
 1829              		@ frame_needed = 1, uses_anonymous_args = 0
 1830 0000 80B5     		push	{r7, lr}
 1831              	.LCFI17:
 1832              		.cfi_def_cfa_offset 8
 1833              		.cfi_offset 7, -8
 1834              		.cfi_offset 14, -4
 1835 0002 86B0     		sub	sp, sp, #24
 1836              	.LCFI18:
 1837              		.cfi_def_cfa_offset 32
 1838 0004 00AF     		add	r7, sp, #0
 1839              	.LCFI19:
 1840              		.cfi_def_cfa_register 7
 1841 0006 7860     		str	r0, [r7, #4]
 1842 0008 3960     		str	r1, [r7]
 903:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t position = 0x00U;
 1843              		.loc 1 903 12
 1844 000a 0023     		movs	r3, #0
 1845 000c 7B61     		str	r3, [r7, #20]
 904:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t iocurrent = 0x00U;
 1846              		.loc 1 904 12
 1847 000e 0023     		movs	r3, #0
 1848 0010 FB60     		str	r3, [r7, #12]
 905:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t temp = 0x00U;
 1849              		.loc 1 905 12
 1850 0012 0023     		movs	r3, #0
 1851 0014 3B61     		str	r3, [r7, #16]
 906:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 907:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
 908:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 909:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 910:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 911:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PULL(GPIO_Init->Pull)); 
 912:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 913:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the port pins */
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   while (((GPIO_Init->Pin) >> position) != RESET)
 1852              		.loc 1 914 9
 1853 0016 4FE1     		b	.L112
 1854              	.L130:
 915:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 916:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Get current io position */
 917:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     iocurrent = (GPIO_Init->Pin) & (1U << position);
 1855              		.loc 1 917 27
 1856 0018 3B68     		ldr	r3, [r7]
 1857 001a 1B68     		ldr	r3, [r3]
 1858              		.loc 1 917 40
 1859 001c 0121     		movs	r1, #1
 1860 001e 7A69     		ldr	r2, [r7, #20]
 1861 0020 9140     		lsls	r1, r1, r2
 1862 0022 0A00     		movs	r2, r1
 1863              		.loc 1 917 15
 1864 0024 1340     		ands	r3, r2
 1865 0026 FB60     		str	r3, [r7, #12]
 918:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
 919:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(iocurrent)
 1866              		.loc 1 919 7
 1867 0028 FB68     		ldr	r3, [r7, #12]
 1868 002a 002B     		cmp	r3, #0
 1869 002c 00D1     		bne	.LCB1608
 1870 002e 40E1     		b	.L113	@long jump
 1871              	.LCB1608:
 920:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 921:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /*--------------------- GPIO Mode Configuration ------------------------*/
 922:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* In case of Alternate function mode selection */
 923:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD)) 
 1872              		.loc 1 923 20
 1873 0030 3B68     		ldr	r3, [r7]
 1874 0032 5B68     		ldr	r3, [r3, #4]
 1875              		.loc 1 923 9
 1876 0034 022B     		cmp	r3, #2
 1877 0036 03D0     		beq	.L114
 1878              		.loc 1 923 60 discriminator 1
 1879 0038 3B68     		ldr	r3, [r7]
 1880 003a 5B68     		ldr	r3, [r3, #4]
 1881              		.loc 1 923 47 discriminator 1
 1882 003c 122B     		cmp	r3, #18
 1883 003e 23D1     		bne	.L115
 1884              	.L114:
 924:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 925:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the Alternate function parameters */
 926:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 927:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 928:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         
 929:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure Alternate function mapped with the current IO */ 
 930:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->AFR[position >> 3];
 1885              		.loc 1 930 36
 1886 0040 7B69     		ldr	r3, [r7, #20]
 1887 0042 DA08     		lsrs	r2, r3, #3
 1888              		.loc 1 930 14
 1889 0044 7B68     		ldr	r3, [r7, #4]
 1890 0046 0832     		adds	r2, r2, #8
 1891 0048 9200     		lsls	r2, r2, #2
 1892 004a D358     		ldr	r3, [r2, r3]
 1893 004c 3B61     		str	r3, [r7, #16]
 931:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, 0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;      
 1894              		.loc 1 931 9
 1895 004e 7B69     		ldr	r3, [r7, #20]
 1896 0050 0722     		movs	r2, #7
 1897 0052 1340     		ands	r3, r2
 1898 0054 9B00     		lsls	r3, r3, #2
 1899 0056 0F22     		movs	r2, #15
 1900 0058 9A40     		lsls	r2, r2, r3
 1901 005a 1300     		movs	r3, r2
 1902 005c DA43     		mvns	r2, r3
 1903 005e 3B69     		ldr	r3, [r7, #16]
 1904 0060 1340     		ands	r3, r2
 1905 0062 3B61     		str	r3, [r7, #16]
 932:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, (uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));    
 1906              		.loc 1 932 9
 1907 0064 3B68     		ldr	r3, [r7]
 1908 0066 1A69     		ldr	r2, [r3, #16]
 1909 0068 7B69     		ldr	r3, [r7, #20]
 1910 006a 0721     		movs	r1, #7
 1911 006c 0B40     		ands	r3, r1
 1912 006e 9B00     		lsls	r3, r3, #2
 1913 0070 9A40     		lsls	r2, r2, r3
 1914 0072 1300     		movs	r3, r2
 1915 0074 3A69     		ldr	r2, [r7, #16]
 1916 0076 1343     		orrs	r3, r2
 1917 0078 3B61     		str	r3, [r7, #16]
 933:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->AFR[position >> 3U] = temp;
 1918              		.loc 1 933 29
 1919 007a 7B69     		ldr	r3, [r7, #20]
 1920 007c DA08     		lsrs	r2, r3, #3
 1921              		.loc 1 933 36
 1922 007e 7B68     		ldr	r3, [r7, #4]
 1923 0080 0832     		adds	r2, r2, #8
 1924 0082 9200     		lsls	r2, r2, #2
 1925 0084 3969     		ldr	r1, [r7, #16]
 1926 0086 D150     		str	r1, [r2, r3]
 1927              	.L115:
 934:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 935:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 936:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
 937:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp = GPIOx->MODER;
 1928              		.loc 1 937 12
 1929 0088 7B68     		ldr	r3, [r7, #4]
 1930 008a 1B68     		ldr	r3, [r3]
 1931 008c 3B61     		str	r3, [r7, #16]
 938:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       CLEAR_BIT(temp, GPIO_MODER_MODER0 << (position * 2U));   
 1932              		.loc 1 938 7
 1933 008e 7B69     		ldr	r3, [r7, #20]
 1934 0090 5B00     		lsls	r3, r3, #1
 1935 0092 0322     		movs	r2, #3
 1936 0094 9A40     		lsls	r2, r2, r3
 1937 0096 1300     		movs	r3, r2
 1938 0098 DA43     		mvns	r2, r3
 1939 009a 3B69     		ldr	r3, [r7, #16]
 1940 009c 1340     		ands	r3, r2
 1941 009e 3B61     		str	r3, [r7, #16]
 939:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(temp, (GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 1942              		.loc 1 939 7
 1943 00a0 3B68     		ldr	r3, [r7]
 1944 00a2 5B68     		ldr	r3, [r3, #4]
 1945 00a4 0322     		movs	r2, #3
 1946 00a6 1A40     		ands	r2, r3
 1947 00a8 7B69     		ldr	r3, [r7, #20]
 1948 00aa 5B00     		lsls	r3, r3, #1
 1949 00ac 9A40     		lsls	r2, r2, r3
 1950 00ae 1300     		movs	r3, r2
 1951 00b0 3A69     		ldr	r2, [r7, #16]
 1952 00b2 1343     		orrs	r3, r2
 1953 00b4 3B61     		str	r3, [r7, #16]
 940:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       GPIOx->MODER = temp;
 1954              		.loc 1 940 20
 1955 00b6 7B68     		ldr	r3, [r7, #4]
 1956 00b8 3A69     		ldr	r2, [r7, #16]
 1957 00ba 1A60     		str	r2, [r3]
 941:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 942:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* In case of Output or Alternate function mode selection */
 943:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 1958              		.loc 1 943 21
 1959 00bc 3B68     		ldr	r3, [r7]
 1960 00be 5B68     		ldr	r3, [r3, #4]
 1961              		.loc 1 943 10
 1962 00c0 012B     		cmp	r3, #1
 1963 00c2 0BD0     		beq	.L116
 1964              		.loc 1 943 65 discriminator 1
 1965 00c4 3B68     		ldr	r3, [r7]
 1966 00c6 5B68     		ldr	r3, [r3, #4]
 1967              		.loc 1 943 52 discriminator 1
 1968 00c8 022B     		cmp	r3, #2
 1969 00ca 07D0     		beq	.L116
 944:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 1970              		.loc 1 944 21 discriminator 2
 1971 00cc 3B68     		ldr	r3, [r7]
 1972 00ce 5B68     		ldr	r3, [r3, #4]
 943:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 1973              		.loc 1 943 92 discriminator 2
 1974 00d0 112B     		cmp	r3, #17
 1975 00d2 03D0     		beq	.L116
 1976              		.loc 1 944 65
 1977 00d4 3B68     		ldr	r3, [r7]
 1978 00d6 5B68     		ldr	r3, [r3, #4]
 1979              		.loc 1 944 52
 1980 00d8 122B     		cmp	r3, #18
 1981 00da 30D1     		bne	.L117
 1982              	.L116:
 945:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 946:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Check the Speed parameter */
 947:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 948:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the IO Speed */
 949:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->OSPEEDR; 
 1983              		.loc 1 949 14
 1984 00dc 7B68     		ldr	r3, [r7, #4]
 1985 00de 9B68     		ldr	r3, [r3, #8]
 1986 00e0 3B61     		str	r3, [r7, #16]
 950:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 1987              		.loc 1 950 9
 1988 00e2 7B69     		ldr	r3, [r7, #20]
 1989 00e4 5B00     		lsls	r3, r3, #1
 1990 00e6 0322     		movs	r2, #3
 1991 00e8 9A40     		lsls	r2, r2, r3
 1992 00ea 1300     		movs	r3, r2
 1993 00ec DA43     		mvns	r2, r3
 1994 00ee 3B69     		ldr	r3, [r7, #16]
 1995 00f0 1340     		ands	r3, r2
 1996 00f2 3B61     		str	r3, [r7, #16]
 951:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, GPIO_Init->Speed << (position * 2U));
 1997              		.loc 1 951 9
 1998 00f4 3B68     		ldr	r3, [r7]
 1999 00f6 DA68     		ldr	r2, [r3, #12]
 2000 00f8 7B69     		ldr	r3, [r7, #20]
 2001 00fa 5B00     		lsls	r3, r3, #1
 2002 00fc 9A40     		lsls	r2, r2, r3
 2003 00fe 1300     		movs	r3, r2
 2004 0100 3A69     		ldr	r2, [r7, #16]
 2005 0102 1343     		orrs	r3, r2
 2006 0104 3B61     		str	r3, [r7, #16]
 952:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->OSPEEDR = temp;
 2007              		.loc 1 952 24
 2008 0106 7B68     		ldr	r3, [r7, #4]
 2009 0108 3A69     		ldr	r2, [r7, #16]
 2010 010a 9A60     		str	r2, [r3, #8]
 953:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 954:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Configure the IO Output Type */
 955:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = GPIOx->OTYPER;
 2011              		.loc 1 955 14
 2012 010c 7B68     		ldr	r3, [r7, #4]
 2013 010e 5B68     		ldr	r3, [r3, #4]
 2014 0110 3B61     		str	r3, [r7, #16]
 956:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, GPIO_OTYPER_OT_0 << position) ;
 2015              		.loc 1 956 9
 2016 0112 0122     		movs	r2, #1
 2017 0114 7B69     		ldr	r3, [r7, #20]
 2018 0116 9A40     		lsls	r2, r2, r3
 2019 0118 1300     		movs	r3, r2
 2020 011a DA43     		mvns	r2, r3
 2021 011c 3B69     		ldr	r3, [r7, #16]
 2022 011e 1340     		ands	r3, r2
 2023 0120 3B61     		str	r3, [r7, #16]
 957:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, ((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 2024              		.loc 1 957 9
 2025 0122 3B68     		ldr	r3, [r7]
 2026 0124 5B68     		ldr	r3, [r3, #4]
 2027 0126 1B09     		lsrs	r3, r3, #4
 2028 0128 0122     		movs	r2, #1
 2029 012a 1A40     		ands	r2, r3
 2030 012c 7B69     		ldr	r3, [r7, #20]
 2031 012e 9A40     		lsls	r2, r2, r3
 2032 0130 1300     		movs	r3, r2
 2033 0132 3A69     		ldr	r2, [r7, #16]
 2034 0134 1343     		orrs	r3, r2
 2035 0136 3B61     		str	r3, [r7, #16]
 958:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         GPIOx->OTYPER = temp;
 2036              		.loc 1 958 23
 2037 0138 7B68     		ldr	r3, [r7, #4]
 2038 013a 3A69     		ldr	r2, [r7, #16]
 2039 013c 5A60     		str	r2, [r3, #4]
 2040              	.L117:
 959:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
 960:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 961:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Activate the Pull-up or Pull down resistor for the current IO */
 962:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       temp = GPIOx->PUPDR;
 2041              		.loc 1 962 12
 2042 013e 7B68     		ldr	r3, [r7, #4]
 2043 0140 DB68     		ldr	r3, [r3, #12]
 2044 0142 3B61     		str	r3, [r7, #16]
 963:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       CLEAR_BIT(temp, GPIO_PUPDR_PUPDR0 << (position * 2U));
 2045              		.loc 1 963 7
 2046 0144 7B69     		ldr	r3, [r7, #20]
 2047 0146 5B00     		lsls	r3, r3, #1
 2048 0148 0322     		movs	r2, #3
 2049 014a 9A40     		lsls	r2, r2, r3
 2050 014c 1300     		movs	r3, r2
 2051 014e DA43     		mvns	r2, r3
 2052 0150 3B69     		ldr	r3, [r7, #16]
 2053 0152 1340     		ands	r3, r2
 2054 0154 3B61     		str	r3, [r7, #16]
 964:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       SET_BIT(temp, (GPIO_Init->Pull) << (position * 2U));
 2055              		.loc 1 964 7
 2056 0156 3B68     		ldr	r3, [r7]
 2057 0158 9A68     		ldr	r2, [r3, #8]
 2058 015a 7B69     		ldr	r3, [r7, #20]
 2059 015c 5B00     		lsls	r3, r3, #1
 2060 015e 9A40     		lsls	r2, r2, r3
 2061 0160 1300     		movs	r3, r2
 2062 0162 3A69     		ldr	r2, [r7, #16]
 2063 0164 1343     		orrs	r3, r2
 2064 0166 3B61     		str	r3, [r7, #16]
 965:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       GPIOx->PUPDR = temp;
 2065              		.loc 1 965 20
 2066 0168 7B68     		ldr	r3, [r7, #4]
 2067 016a 3A69     		ldr	r2, [r7, #16]
 2068 016c DA60     		str	r2, [r3, #12]
 966:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 967:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /*--------------------- EXTI Mode Configuration ------------------------*/
 968:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Configure the External Interrupt or event for the current IO */
 969:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE) 
 2069              		.loc 1 969 20
 2070 016e 3B68     		ldr	r3, [r7]
 2071 0170 5A68     		ldr	r2, [r3, #4]
 2072              		.loc 1 969 27
 2073 0172 8023     		movs	r3, #128
 2074 0174 5B05     		lsls	r3, r3, #21
 2075 0176 1340     		ands	r3, r2
 2076              		.loc 1 969 9
 2077 0178 00D1     		bne	.LCB1780
 2078 017a 9AE0     		b	.L113	@long jump
 2079              	.LCB1780:
 2080              	.LBB6:
 970:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
 971:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Enable SYSCFG Clock */
 972:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_RCC_SYSCFG_CLK_ENABLE();
 2081              		.loc 1 972 9
 2082 017c 544B     		ldr	r3, .L131
 2083 017e 9A69     		ldr	r2, [r3, #24]
 2084 0180 534B     		ldr	r3, .L131
 2085 0182 0121     		movs	r1, #1
 2086 0184 0A43     		orrs	r2, r1
 2087 0186 9A61     		str	r2, [r3, #24]
 2088 0188 514B     		ldr	r3, .L131
 2089 018a 9B69     		ldr	r3, [r3, #24]
 2090 018c 0122     		movs	r2, #1
 2091 018e 1340     		ands	r3, r2
 2092 0190 BB60     		str	r3, [r7, #8]
 2093 0192 BB68     		ldr	r3, [r7, #8]
 2094              	.LBE6:
 973:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 974:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = SYSCFG->EXTICR[position >> 2];
 2095              		.loc 1 974 22
 2096 0194 4F4A     		ldr	r2, .L131+4
 2097              		.loc 1 974 40
 2098 0196 7B69     		ldr	r3, [r7, #20]
 2099 0198 9B08     		lsrs	r3, r3, #2
 2100              		.loc 1 974 14
 2101 019a 0233     		adds	r3, r3, #2
 2102 019c 9B00     		lsls	r3, r3, #2
 2103 019e 9B58     		ldr	r3, [r3, r2]
 2104 01a0 3B61     		str	r3, [r7, #16]
 975:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (0x0FU) << (4U * (position & 0x03U)));
 2105              		.loc 1 975 9
 2106 01a2 7B69     		ldr	r3, [r7, #20]
 2107 01a4 0322     		movs	r2, #3
 2108 01a6 1340     		ands	r3, r2
 2109 01a8 9B00     		lsls	r3, r3, #2
 2110 01aa 0F22     		movs	r2, #15
 2111 01ac 9A40     		lsls	r2, r2, r3
 2112 01ae 1300     		movs	r3, r2
 2113 01b0 DA43     		mvns	r2, r3
 2114 01b2 3B69     		ldr	r3, [r7, #16]
 2115 01b4 1340     		ands	r3, r2
 2116 01b6 3B61     		str	r3, [r7, #16]
 976:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 2117              		.loc 1 976 9
 2118 01b8 7A68     		ldr	r2, [r7, #4]
 2119 01ba 9023     		movs	r3, #144
 2120 01bc DB05     		lsls	r3, r3, #23
 2121 01be 9A42     		cmp	r2, r3
 2122 01c0 13D0     		beq	.L118
 2123              		.loc 1 976 9 is_stmt 0 discriminator 1
 2124 01c2 7B68     		ldr	r3, [r7, #4]
 2125 01c4 444A     		ldr	r2, .L131+8
 2126 01c6 9342     		cmp	r3, r2
 2127 01c8 0DD0     		beq	.L119
 2128              		.loc 1 976 9 discriminator 3
 2129 01ca 7B68     		ldr	r3, [r7, #4]
 2130 01cc 434A     		ldr	r2, .L131+12
 2131 01ce 9342     		cmp	r3, r2
 2132 01d0 07D0     		beq	.L120
 2133              		.loc 1 976 9 discriminator 5
 2134 01d2 7B68     		ldr	r3, [r7, #4]
 2135 01d4 424A     		ldr	r2, .L131+16
 2136 01d6 9342     		cmp	r3, r2
 2137 01d8 01D1     		bne	.L121
 2138              		.loc 1 976 9 discriminator 7
 2139 01da 0323     		movs	r3, #3
 2140 01dc 06E0     		b	.L125
 2141              	.L121:
 2142              		.loc 1 976 9 discriminator 8
 2143 01de 0523     		movs	r3, #5
 2144 01e0 04E0     		b	.L125
 2145              	.L120:
 2146              		.loc 1 976 9 discriminator 6
 2147 01e2 0223     		movs	r3, #2
 2148 01e4 02E0     		b	.L125
 2149              	.L119:
 2150              		.loc 1 976 9 discriminator 4
 2151 01e6 0123     		movs	r3, #1
 2152 01e8 00E0     		b	.L125
 2153              	.L118:
 2154              		.loc 1 976 9 discriminator 2
 2155 01ea 0023     		movs	r3, #0
 2156              	.L125:
 2157              		.loc 1 976 9 discriminator 16
 2158 01ec 7A69     		ldr	r2, [r7, #20]
 2159 01ee 0321     		movs	r1, #3
 2160 01f0 0A40     		ands	r2, r1
 2161 01f2 9200     		lsls	r2, r2, #2
 2162 01f4 9340     		lsls	r3, r3, r2
 2163 01f6 3A69     		ldr	r2, [r7, #16]
 2164 01f8 1343     		orrs	r3, r2
 2165 01fa 3B61     		str	r3, [r7, #16]
 977:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         SYSCFG->EXTICR[position >> 2] = temp;
 2166              		.loc 1 977 15 is_stmt 1 discriminator 16
 2167 01fc 3549     		ldr	r1, .L131+4
 2168              		.loc 1 977 33 discriminator 16
 2169 01fe 7B69     		ldr	r3, [r7, #20]
 2170 0200 9B08     		lsrs	r3, r3, #2
 2171              		.loc 1 977 39 discriminator 16
 2172 0202 0233     		adds	r3, r3, #2
 2173 0204 9B00     		lsls	r3, r3, #2
 2174 0206 3A69     		ldr	r2, [r7, #16]
 2175 0208 5A50     		str	r2, [r3, r1]
 978:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****                   
 979:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Clear EXTI line configuration */
 980:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->IMR;
 2176              		.loc 1 980 20 discriminator 16
 2177 020a 364B     		ldr	r3, .L131+20
 2178              		.loc 1 980 14 discriminator 16
 2179 020c 1B68     		ldr	r3, [r3]
 2180 020e 3B61     		str	r3, [r7, #16]
 981:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent);
 2181              		.loc 1 981 9 discriminator 16
 2182 0210 FB68     		ldr	r3, [r7, #12]
 2183 0212 DA43     		mvns	r2, r3
 2184 0214 3B69     		ldr	r3, [r7, #16]
 2185 0216 1340     		ands	r3, r2
 2186 0218 3B61     		str	r3, [r7, #16]
 982:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 2187              		.loc 1 982 22 discriminator 16
 2188 021a 3B68     		ldr	r3, [r7]
 2189 021c 5A68     		ldr	r2, [r3, #4]
 2190              		.loc 1 982 29 discriminator 16
 2191 021e 8023     		movs	r3, #128
 2192 0220 5B02     		lsls	r3, r3, #9
 2193 0222 1340     		ands	r3, r2
 2194              		.loc 1 982 11 discriminator 16
 2195 0224 03D0     		beq	.L126
 983:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
 984:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2196              		.loc 1 984 11
 2197 0226 3A69     		ldr	r2, [r7, #16]
 2198 0228 FB68     		ldr	r3, [r7, #12]
 2199 022a 1343     		orrs	r3, r2
 2200 022c 3B61     		str	r3, [r7, #16]
 2201              	.L126:
 985:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 986:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->IMR = temp;
 2202              		.loc 1 986 13
 2203 022e 2D4B     		ldr	r3, .L131+20
 2204              		.loc 1 986 19
 2205 0230 3A69     		ldr	r2, [r7, #16]
 2206 0232 1A60     		str	r2, [r3]
 987:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
 988:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->EMR;
 2207              		.loc 1 988 20
 2208 0234 2B4B     		ldr	r3, .L131+20
 2209              		.loc 1 988 14
 2210 0236 5B68     		ldr	r3, [r3, #4]
 2211 0238 3B61     		str	r3, [r7, #16]
 989:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent);      
 2212              		.loc 1 989 9
 2213 023a FB68     		ldr	r3, [r7, #12]
 2214 023c DA43     		mvns	r2, r3
 2215 023e 3B69     		ldr	r3, [r7, #16]
 2216 0240 1340     		ands	r3, r2
 2217 0242 3B61     		str	r3, [r7, #16]
 990:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 2218              		.loc 1 990 22
 2219 0244 3B68     		ldr	r3, [r7]
 2220 0246 5A68     		ldr	r2, [r3, #4]
 2221              		.loc 1 990 29
 2222 0248 8023     		movs	r3, #128
 2223 024a 9B02     		lsls	r3, r3, #10
 2224 024c 1340     		ands	r3, r2
 2225              		.loc 1 990 11
 2226 024e 03D0     		beq	.L127
 991:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         { 
 992:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2227              		.loc 1 992 11
 2228 0250 3A69     		ldr	r2, [r7, #16]
 2229 0252 FB68     		ldr	r3, [r7, #12]
 2230 0254 1343     		orrs	r3, r2
 2231 0256 3B61     		str	r3, [r7, #16]
 2232              	.L127:
 993:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
 994:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->EMR = temp;
 2233              		.loc 1 994 13
 2234 0258 224B     		ldr	r3, .L131+20
 2235              		.loc 1 994 19
 2236 025a 3A69     		ldr	r2, [r7, #16]
 2237 025c 5A60     		str	r2, [r3, #4]
 995:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
 996:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Clear Rising Falling edge configuration */
 997:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->RTSR;
 2238              		.loc 1 997 20
 2239 025e 214B     		ldr	r3, .L131+20
 2240              		.loc 1 997 14
 2241 0260 9B68     		ldr	r3, [r3, #8]
 2242 0262 3B61     		str	r3, [r7, #16]
 998:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent); 
 2243              		.loc 1 998 9
 2244 0264 FB68     		ldr	r3, [r7, #12]
 2245 0266 DA43     		mvns	r2, r3
 2246 0268 3B69     		ldr	r3, [r7, #16]
 2247 026a 1340     		ands	r3, r2
 2248 026c 3B61     		str	r3, [r7, #16]
 999:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 2249              		.loc 1 999 22
 2250 026e 3B68     		ldr	r3, [r7]
 2251 0270 5A68     		ldr	r2, [r3, #4]
 2252              		.loc 1 999 29
 2253 0272 8023     		movs	r3, #128
 2254 0274 5B03     		lsls	r3, r3, #13
 2255 0276 1340     		ands	r3, r2
 2256              		.loc 1 999 11
 2257 0278 03D0     		beq	.L128
1000:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
1001:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2258              		.loc 1 1001 11
 2259 027a 3A69     		ldr	r2, [r7, #16]
 2260 027c FB68     		ldr	r3, [r7, #12]
 2261 027e 1343     		orrs	r3, r2
 2262 0280 3B61     		str	r3, [r7, #16]
 2263              	.L128:
1002:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
1003:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->RTSR = temp;
 2264              		.loc 1 1003 13
 2265 0282 184B     		ldr	r3, .L131+20
 2266              		.loc 1 1003 20
 2267 0284 3A69     		ldr	r2, [r7, #16]
 2268 0286 9A60     		str	r2, [r3, #8]
1004:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1005:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         temp = EXTI->FTSR;
 2269              		.loc 1 1005 20
 2270 0288 164B     		ldr	r3, .L131+20
 2271              		.loc 1 1005 14
 2272 028a DB68     		ldr	r3, [r3, #12]
 2273 028c 3B61     		str	r3, [r7, #16]
1006:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(temp, (uint32_t)iocurrent); 
 2274              		.loc 1 1006 9
 2275 028e FB68     		ldr	r3, [r7, #12]
 2276 0290 DA43     		mvns	r2, r3
 2277 0292 3B69     		ldr	r3, [r7, #16]
 2278 0294 1340     		ands	r3, r2
 2279 0296 3B61     		str	r3, [r7, #16]
1007:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 2280              		.loc 1 1007 22
 2281 0298 3B68     		ldr	r3, [r7]
 2282 029a 5A68     		ldr	r2, [r3, #4]
 2283              		.loc 1 1007 29
 2284 029c 8023     		movs	r3, #128
 2285 029e 9B03     		lsls	r3, r3, #14
 2286 02a0 1340     		ands	r3, r2
 2287              		.loc 1 1007 11
 2288 02a2 03D0     		beq	.L129
1008:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         {
1009:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****           SET_BIT(temp, iocurrent); 
 2289              		.loc 1 1009 11
 2290 02a4 3A69     		ldr	r2, [r7, #16]
 2291 02a6 FB68     		ldr	r3, [r7, #12]
 2292 02a8 1343     		orrs	r3, r2
 2293 02aa 3B61     		str	r3, [r7, #16]
 2294              	.L129:
1010:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         }
1011:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         EXTI->FTSR = temp;
 2295              		.loc 1 1011 13
 2296 02ac 0D4B     		ldr	r3, .L131+20
 2297              		.loc 1 1011 20
 2298 02ae 3A69     		ldr	r2, [r7, #16]
 2299 02b0 DA60     		str	r2, [r3, #12]
 2300              	.L113:
1012:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1013:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1014:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     
1015:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     position++;
 2301              		.loc 1 1015 13
 2302 02b2 7B69     		ldr	r3, [r7, #20]
 2303 02b4 0133     		adds	r3, r3, #1
 2304 02b6 7B61     		str	r3, [r7, #20]
 2305              	.L112:
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2306              		.loc 1 914 21
 2307 02b8 3B68     		ldr	r3, [r7]
 2308 02ba 1A68     		ldr	r2, [r3]
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2309              		.loc 1 914 28
 2310 02bc 7B69     		ldr	r3, [r7, #20]
 2311 02be DA40     		lsrs	r2, r2, r3
 2312 02c0 131E     		subs	r3, r2, #0
 914:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2313              		.loc 1 914 41
 2314 02c2 00D0     		beq	.LCB1977
 2315 02c4 A8E6     		b	.L130	@long jump
 2316              	.LCB1977:
1016:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   } 
1017:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2317              		.loc 1 1017 1
 2318 02c6 C046     		nop
 2319 02c8 C046     		nop
 2320 02ca BD46     		mov	sp, r7
 2321 02cc 06B0     		add	sp, sp, #24
 2322              		@ sp needed
 2323 02ce 80BD     		pop	{r7, pc}
 2324              	.L132:
 2325              		.align	2
 2326              	.L131:
 2327 02d0 00100240 		.word	1073876992
 2328 02d4 00000140 		.word	1073807360
 2329 02d8 00040048 		.word	1207960576
 2330 02dc 00080048 		.word	1207961600
 2331 02e0 000C0048 		.word	1207962624
 2332 02e4 00040140 		.word	1073808384
 2333              		.cfi_endproc
 2334              	.LFE44:
 2336              		.section	.text.HAL_GPIO_WritePin,"ax",%progbits
 2337              		.align	1
 2338              		.global	HAL_GPIO_WritePin
 2339              		.syntax unified
 2340              		.code	16
 2341              		.thumb_func
 2342              		.fpu softvfp
 2344              	HAL_GPIO_WritePin:
 2345              	.LFB45:
1018:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1019:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1020:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Set or clear the selected data port bit.
1021:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   This function uses GPIOx_BSRR and GPIOx_BRR registers to allow atomic read/modify
1022:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         accesses. In this way, there is no risk of an IRQ occurring between
1023:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         the read and the modify access.
1024:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *
1025:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIOx: where x can be (A..H) to select the GPIO peripheral for STM32F0 family
1026:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  GPIO_Pin: specifies the port bit to be written.
1027:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
1028:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  PinState: specifies the value to be written to the selected bit.
1029:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *          This parameter can be one of the GPIO_PinState enum values:
1030:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *            @arg GPIO_PIN_RESET: to clear the port pin
1031:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *            @arg GPIO_PIN_SET: to set the port pin
1032:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval None
1033:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1034:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
1035:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2346              		.loc 1 1035 1
 2347              		.cfi_startproc
 2348              		@ args = 0, pretend = 0, frame = 8
 2349              		@ frame_needed = 1, uses_anonymous_args = 0
 2350 0000 80B5     		push	{r7, lr}
 2351              	.LCFI20:
 2352              		.cfi_def_cfa_offset 8
 2353              		.cfi_offset 7, -8
 2354              		.cfi_offset 14, -4
 2355 0002 82B0     		sub	sp, sp, #8
 2356              	.LCFI21:
 2357              		.cfi_def_cfa_offset 16
 2358 0004 00AF     		add	r7, sp, #0
 2359              	.LCFI22:
 2360              		.cfi_def_cfa_register 7
 2361 0006 7860     		str	r0, [r7, #4]
 2362 0008 0800     		movs	r0, r1
 2363 000a 1100     		movs	r1, r2
 2364 000c BB1C     		adds	r3, r7, #2
 2365 000e 021C     		adds	r2, r0, #0
 2366 0010 1A80     		strh	r2, [r3]
 2367 0012 7B1C     		adds	r3, r7, #1
 2368 0014 0A1C     		adds	r2, r1, #0
 2369 0016 1A70     		strb	r2, [r3]
1036:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
1037:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN(GPIO_Pin));
1038:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_GPIO_PIN_ACTION(PinState));
1039:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1040:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (PinState != GPIO_PIN_RESET)
 2370              		.loc 1 1040 6
 2371 0018 7B1C     		adds	r3, r7, #1
 2372 001a 1B78     		ldrb	r3, [r3]
 2373 001c 002B     		cmp	r3, #0
 2374 001e 04D0     		beq	.L134
1041:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1042:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     GPIOx->BSRR = (uint32_t)GPIO_Pin;
 2375              		.loc 1 1042 19
 2376 0020 BB1C     		adds	r3, r7, #2
 2377 0022 1A88     		ldrh	r2, [r3]
 2378              		.loc 1 1042 17
 2379 0024 7B68     		ldr	r3, [r7, #4]
 2380 0026 9A61     		str	r2, [r3, #24]
1043:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1044:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1045:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1046:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     GPIOx->BRR = (uint32_t)GPIO_Pin;
1047:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1048:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }										  
 2381              		.loc 1 1048 1
 2382 0028 03E0     		b	.L136
 2383              	.L134:
1046:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 2384              		.loc 1 1046 18
 2385 002a BB1C     		adds	r3, r7, #2
 2386 002c 1A88     		ldrh	r2, [r3]
1046:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
 2387              		.loc 1 1046 16
 2388 002e 7B68     		ldr	r3, [r7, #4]
 2389 0030 9A62     		str	r2, [r3, #40]
 2390              	.L136:
 2391              		.loc 1 1048 1
 2392 0032 C046     		nop
 2393 0034 BD46     		mov	sp, r7
 2394 0036 02B0     		add	sp, sp, #8
 2395              		@ sp needed
 2396 0038 80BD     		pop	{r7, pc}
 2397              		.cfi_endproc
 2398              	.LFE45:
 2400              		.section	.text.UART_WaitOnFlagUntilTimeout,"ax",%progbits
 2401              		.align	1
 2402              		.global	UART_WaitOnFlagUntilTimeout
 2403              		.syntax unified
 2404              		.code	16
 2405              		.thumb_func
 2406              		.fpu softvfp
 2408              	UART_WaitOnFlagUntilTimeout:
 2409              	.LFB46:
1049:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1050:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1051:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief  Handle UART Communication Timeout.
1052:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  huart UART handle.
1053:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Flag Specifies the UART flag to check
1054:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Status Flag status (SET or RESET)
1055:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Tickstart Tick start value
1056:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param  Timeout Timeout duration
1057:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1058:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1059:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus 
1060:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2410              		.loc 1 1060 1
 2411              		.cfi_startproc
 2412              		@ args = 4, pretend = 0, frame = 16
 2413              		@ frame_needed = 1, uses_anonymous_args = 0
 2414 0000 80B5     		push	{r7, lr}
 2415              	.LCFI23:
 2416              		.cfi_def_cfa_offset 8
 2417              		.cfi_offset 7, -8
 2418              		.cfi_offset 14, -4
 2419 0002 84B0     		sub	sp, sp, #16
 2420              	.LCFI24:
 2421              		.cfi_def_cfa_offset 24
 2422 0004 00AF     		add	r7, sp, #0
 2423              	.LCFI25:
 2424              		.cfi_def_cfa_register 7
 2425 0006 F860     		str	r0, [r7, #12]
 2426 0008 B960     		str	r1, [r7, #8]
 2427 000a 3B60     		str	r3, [r7]
 2428 000c FB1D     		adds	r3, r7, #7
 2429 000e 1A70     		strb	r2, [r3]
1061:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Wait until flag is set */
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   while((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 2430              		.loc 1 1062 8
 2431 0010 2BE0     		b	.L138
 2432              	.L141:
1063:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1064:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check for the Timeout */
1065:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(Timeout != HAL_MAX_DELAY)
 2433              		.loc 1 1065 7
 2434 0012 BB69     		ldr	r3, [r7, #24]
 2435 0014 0133     		adds	r3, r3, #1
 2436 0016 28D0     		beq	.L138
1066:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1067:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 2437              		.loc 1 1067 9
 2438 0018 BB69     		ldr	r3, [r7, #24]
 2439 001a 002B     		cmp	r3, #0
 2440 001c 07D0     		beq	.L139
 2441              		.loc 1 1067 31 discriminator 1
 2442 001e FFF7FEFF 		bl	HAL_GetTick
 2443 0022 0200     		movs	r2, r0
 2444              		.loc 1 1067 44 discriminator 1
 2445 0024 3B68     		ldr	r3, [r7]
 2446 0026 D31A     		subs	r3, r2, r3
 2447              		.loc 1 1067 26 discriminator 1
 2448 0028 BA69     		ldr	r2, [r7, #24]
 2449 002a 9A42     		cmp	r2, r3
 2450 002c 1DD2     		bcs	.L138
 2451              	.L139:
1068:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1069:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for t
1070:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 2452              		.loc 1 1070 9
 2453 002e FB68     		ldr	r3, [r7, #12]
 2454 0030 1B68     		ldr	r3, [r3]
 2455 0032 1A68     		ldr	r2, [r3]
 2456 0034 FB68     		ldr	r3, [r7, #12]
 2457 0036 1B68     		ldr	r3, [r3]
 2458 0038 1649     		ldr	r1, .L143
 2459 003a 0A40     		ands	r2, r1
 2460 003c 1A60     		str	r2, [r3]
1071:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 2461              		.loc 1 1071 9
 2462 003e FB68     		ldr	r3, [r7, #12]
 2463 0040 1B68     		ldr	r3, [r3]
 2464 0042 9A68     		ldr	r2, [r3, #8]
 2465 0044 FB68     		ldr	r3, [r7, #12]
 2466 0046 1B68     		ldr	r3, [r3]
 2467 0048 0121     		movs	r1, #1
 2468 004a 8A43     		bics	r2, r1
 2469 004c 9A60     		str	r2, [r3, #8]
1072:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1073:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->gState  = HAL_UART_STATE_READY;
 2470              		.loc 1 1073 24
 2471 004e FB68     		ldr	r3, [r7, #12]
 2472 0050 6922     		movs	r2, #105
 2473 0052 2021     		movs	r1, #32
 2474 0054 9954     		strb	r1, [r3, r2]
1074:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->RxState = HAL_UART_STATE_READY;
 2475              		.loc 1 1074 24
 2476 0056 FB68     		ldr	r3, [r7, #12]
 2477 0058 6A22     		movs	r2, #106
 2478 005a 2021     		movs	r1, #32
 2479 005c 9954     		strb	r1, [r3, r2]
1075:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1076:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Process Unlocked */
1077:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         __HAL_UNLOCK(huart);
 2480              		.loc 1 1077 9
 2481 005e FB68     		ldr	r3, [r7, #12]
 2482 0060 6822     		movs	r2, #104
 2483 0062 0021     		movs	r1, #0
 2484 0064 9954     		strb	r1, [r3, r2]
1078:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 2485              		.loc 1 1078 16
 2486 0066 0323     		movs	r3, #3
 2487 0068 0FE0     		b	.L140
 2488              	.L138:
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2489              		.loc 1 1062 10
 2490 006a FB68     		ldr	r3, [r7, #12]
 2491 006c 1B68     		ldr	r3, [r3]
 2492 006e DB69     		ldr	r3, [r3, #28]
 2493 0070 BA68     		ldr	r2, [r7, #8]
 2494 0072 1340     		ands	r3, r2
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2495              		.loc 1 1062 49
 2496 0074 BA68     		ldr	r2, [r7, #8]
 2497 0076 D31A     		subs	r3, r2, r3
 2498 0078 5A42     		rsbs	r2, r3, #0
 2499 007a 5341     		adcs	r3, r3, r2
 2500 007c DBB2     		uxtb	r3, r3
 2501 007e 1A00     		movs	r2, r3
1062:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
 2502              		.loc 1 1062 58
 2503 0080 FB1D     		adds	r3, r7, #7
 2504 0082 1B78     		ldrb	r3, [r3]
 2505 0084 9A42     		cmp	r2, r3
 2506 0086 C4D0     		beq	.L141
1079:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1080:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1081:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1082:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 2507              		.loc 1 1082 10
 2508 0088 0023     		movs	r3, #0
 2509              	.L140:
1083:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2510              		.loc 1 1083 1
 2511 008a 1800     		movs	r0, r3
 2512 008c BD46     		mov	sp, r7
 2513 008e 04B0     		add	sp, sp, #16
 2514              		@ sp needed
 2515 0090 80BD     		pop	{r7, pc}
 2516              	.L144:
 2517 0092 C046     		.align	2
 2518              	.L143:
 2519 0094 5FFEFFFF 		.word	-417
 2520              		.cfi_endproc
 2521              	.LFE46:
 2523              		.section	.text.UART_CheckIdleState,"ax",%progbits
 2524              		.align	1
 2525              		.global	UART_CheckIdleState
 2526              		.syntax unified
 2527              		.code	16
 2528              		.thumb_func
 2529              		.fpu softvfp
 2531              	UART_CheckIdleState:
 2532              	.LFB47:
1084:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1085:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1086:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Check the UART Idle State.
1087:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart UART handle.
1088:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1089:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1090:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
1091:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2533              		.loc 1 1091 1
 2534              		.cfi_startproc
 2535              		@ args = 0, pretend = 0, frame = 8
 2536              		@ frame_needed = 1, uses_anonymous_args = 0
 2537 0000 80B5     		push	{r7, lr}
 2538              	.LCFI26:
 2539              		.cfi_def_cfa_offset 8
 2540              		.cfi_offset 7, -8
 2541              		.cfi_offset 14, -4
 2542 0002 82B0     		sub	sp, sp, #8
 2543              	.LCFI27:
 2544              		.cfi_def_cfa_offset 16
 2545 0004 00AF     		add	r7, sp, #0
 2546              	.LCFI28:
 2547              		.cfi_def_cfa_register 7
 2548 0006 7860     		str	r0, [r7, #4]
1092:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&
1093:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
1094:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F0
1095:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1096:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Initialize the UART ErrorCode */
1097:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->ErrorCode = HAL_UART_ERROR_NONE;
 2549              		.loc 1 1097 20
 2550 0008 7B68     		ldr	r3, [r7, #4]
 2551 000a 0022     		movs	r2, #0
 2552 000c DA66     		str	r2, [r3, #108]
1098:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1099:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F070x6)&
1100:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Init tickstart for timeout managment*/
1101:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tickstart = HAL_GetTick();
1102:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1103:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* TEACK and REACK bits in ISR are checked only when available (not available on all F0 devices).
1104:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****      Bits are defined for some specific devices, and are available only for UART instances supporti
1105:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1106:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (IS_UART_WAKEUP_FROMSTOP_INSTANCE(huart->Instance))
1107:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1108:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the Transmitter is enabled */
1109:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
1110:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1111:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait until TEACK flag is set */
1112:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VAL
1113:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1114:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Timeout occurred */
1115:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
1116:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1117:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1118:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1119:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check if the Receiver is enabled */
1120:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
1121:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1122:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       /* Wait until REACK flag is set */
1123:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VAL
1124:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1125:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         /* Timeout occurred */
1126:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
1127:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1128:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1129:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1130:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif /* !defined(STM32F030x6) && !defined(STM32F030x8)&& !defined(STM32F070xB)&& !defined(STM32F0
1131:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1132:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Initialize the UART State */
1133:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->gState  = HAL_UART_STATE_READY;
 2553              		.loc 1 1133 18
 2554 000e 7B68     		ldr	r3, [r7, #4]
 2555 0010 6922     		movs	r2, #105
 2556 0012 2021     		movs	r1, #32
 2557 0014 9954     		strb	r1, [r3, r2]
1134:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->RxState = HAL_UART_STATE_READY;
 2558              		.loc 1 1134 18
 2559 0016 7B68     		ldr	r3, [r7, #4]
 2560 0018 6A22     		movs	r2, #106
 2561 001a 2021     		movs	r1, #32
 2562 001c 9954     		strb	r1, [r3, r2]
1135:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1136:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Process Unlocked */
1137:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UNLOCK(huart);
 2563              		.loc 1 1137 3
 2564 001e 7B68     		ldr	r3, [r7, #4]
 2565 0020 6822     		movs	r2, #104
 2566 0022 0021     		movs	r1, #0
 2567 0024 9954     		strb	r1, [r3, r2]
1138:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1139:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return HAL_OK;
 2568              		.loc 1 1139 10
 2569 0026 0023     		movs	r3, #0
1140:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 2570              		.loc 1 1140 1
 2571 0028 1800     		movs	r0, r3
 2572 002a BD46     		mov	sp, r7
 2573 002c 02B0     		add	sp, sp, #8
 2574              		@ sp needed
 2575 002e 80BD     		pop	{r7, pc}
 2576              		.cfi_endproc
 2577              	.LFE47:
 2579              		.global	__aeabi_uidiv
 2580              		.section	.text.UART_SetConfig,"ax",%progbits
 2581              		.align	1
 2582              		.global	UART_SetConfig
 2583              		.syntax unified
 2584              		.code	16
 2585              		.thumb_func
 2586              		.fpu softvfp
 2588              	UART_SetConfig:
 2589              	.LFB48:
1141:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1142:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
1143:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 2590              		.loc 1 1143 1
 2591              		.cfi_startproc
 2592              		@ args = 0, pretend = 0, frame = 24
 2593              		@ frame_needed = 1, uses_anonymous_args = 0
 2594 0000 90B5     		push	{r4, r7, lr}
 2595              	.LCFI29:
 2596              		.cfi_def_cfa_offset 12
 2597              		.cfi_offset 4, -12
 2598              		.cfi_offset 7, -8
 2599              		.cfi_offset 14, -4
 2600 0002 87B0     		sub	sp, sp, #28
 2601              	.LCFI30:
 2602              		.cfi_def_cfa_offset 40
 2603 0004 00AF     		add	r7, sp, #0
 2604              	.LCFI31:
 2605              		.cfi_def_cfa_register 7
 2606 0006 7860     		str	r0, [r7, #4]
1144:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tmpreg                     = 0x00000000U;
 2607              		.loc 1 1144 12
 2608 0008 0023     		movs	r3, #0
 2609 000a FB60     		str	r3, [r7, #12]
1145:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   UART_ClockSourceTypeDef clocksource = UART_CLOCKSOURCE_UNDEFINED;
 2610              		.loc 1 1145 27
 2611 000c 1723     		movs	r3, #23
 2612 000e FB18     		adds	r3, r7, r3
 2613 0010 1022     		movs	r2, #16
 2614 0012 1A70     		strb	r2, [r3]
1146:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t brrtemp                    = 0x0000U;
 2615              		.loc 1 1146 12
 2616 0014 0A23     		movs	r3, #10
 2617 0016 FB18     		adds	r3, r7, r3
 2618 0018 0022     		movs	r2, #0
 2619 001a 1A80     		strh	r2, [r3]
1147:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t usartdiv                   = 0x0000U;
 2620              		.loc 1 1147 12
 2621 001c 1423     		movs	r3, #20
 2622 001e FB18     		adds	r3, r7, r3
 2623 0020 0022     		movs	r2, #0
 2624 0022 1A80     		strh	r2, [r3]
1148:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   HAL_StatusTypeDef ret               = HAL_OK;
 2625              		.loc 1 1148 21
 2626 0024 1323     		movs	r3, #19
 2627 0026 FB18     		adds	r3, r7, r3
 2628 0028 0022     		movs	r2, #0
 2629 002a 1A70     		strb	r2, [r3]
1149:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1150:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the parameters */
1151:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
1152:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
1153:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
1154:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_PARITY(huart->Init.Parity));
1155:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_MODE(huart->Init.Mode));
1156:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
1157:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_ONE_BIT_SAMPLE(huart->Init.OneBitSampling));
1158:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
1159:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1160:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1161:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR1 Configuration -----------------------*/
1162:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Clear M, PCE, PS, TE, RE and OVER8 bits and configure
1163:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  the UART Word Length, Parity, Mode and oversampling:
1164:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set the M bits according to huart->Init.WordLength value
1165:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set PCE and PS bits according to huart->Init.Parity value
1166:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set TE and RE bits according to huart->Init.Mode value
1167:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *  set OVER8 bit according to huart->Init.OverSampling value */
1168:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.O
 2630              		.loc 1 1168 33
 2631 002c 7B68     		ldr	r3, [r7, #4]
 2632 002e 9A68     		ldr	r2, [r3, #8]
 2633              		.loc 1 1168 58
 2634 0030 7B68     		ldr	r3, [r7, #4]
 2635 0032 1B69     		ldr	r3, [r3, #16]
 2636              		.loc 1 1168 45
 2637 0034 1A43     		orrs	r2, r3
 2638              		.loc 1 1168 79
 2639 0036 7B68     		ldr	r3, [r7, #4]
 2640 0038 5B69     		ldr	r3, [r3, #20]
 2641              		.loc 1 1168 66
 2642 003a 1A43     		orrs	r2, r3
 2643              		.loc 1 1168 98
 2644 003c 7B68     		ldr	r3, [r7, #4]
 2645 003e DB69     		ldr	r3, [r3, #28]
 2646              		.loc 1 1168 10
 2647 0040 1343     		orrs	r3, r2
 2648 0042 FB60     		str	r3, [r7, #12]
1169:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR1, UART_CR1_FIELDS, tmpreg);
 2649              		.loc 1 1169 3
 2650 0044 7B68     		ldr	r3, [r7, #4]
 2651 0046 1B68     		ldr	r3, [r3]
 2652 0048 1B68     		ldr	r3, [r3]
 2653 004a 974A     		ldr	r2, .L168
 2654 004c 1340     		ands	r3, r2
 2655 004e 1900     		movs	r1, r3
 2656 0050 7B68     		ldr	r3, [r7, #4]
 2657 0052 1B68     		ldr	r3, [r3]
 2658 0054 FA68     		ldr	r2, [r7, #12]
 2659 0056 0A43     		orrs	r2, r1
 2660 0058 1A60     		str	r2, [r3]
1170:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1171:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR2 Configuration -----------------------*/
1172:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure the UART Stop Bits: Set STOP[13:12] bits according
1173:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * to huart->Init.StopBits value */
1174:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 2661              		.loc 1 1174 3
 2662 005a 7B68     		ldr	r3, [r7, #4]
 2663 005c 1B68     		ldr	r3, [r3]
 2664 005e 5B68     		ldr	r3, [r3, #4]
 2665 0060 924A     		ldr	r2, .L168+4
 2666 0062 1340     		ands	r3, r2
 2667 0064 1900     		movs	r1, r3
 2668 0066 7B68     		ldr	r3, [r7, #4]
 2669 0068 DA68     		ldr	r2, [r3, #12]
 2670 006a 7B68     		ldr	r3, [r7, #4]
 2671 006c 1B68     		ldr	r3, [r3]
 2672 006e 0A43     		orrs	r2, r1
 2673 0070 5A60     		str	r2, [r3, #4]
1175:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1176:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART CR3 Configuration -----------------------*/
1177:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Configure
1178:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * - UART HardWare Flow Control: set CTSE and RTSE bits according
1179:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *   to huart->Init.HwFlowCtl value
1180:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    * - one-bit sampling method versus three samples' majority rule according
1181:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****    *   to huart->Init.OneBitSampling */
1182:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   tmpreg = (uint32_t)huart->Init.HwFlowCtl | huart->Init.OneBitSampling ;
 2674              		.loc 1 1182 33
 2675 0072 7B68     		ldr	r3, [r7, #4]
 2676 0074 9A69     		ldr	r2, [r3, #24]
 2677              		.loc 1 1182 57
 2678 0076 7B68     		ldr	r3, [r7, #4]
 2679 0078 1B6A     		ldr	r3, [r3, #32]
 2680              		.loc 1 1182 10
 2681 007a 1343     		orrs	r3, r2
 2682 007c FB60     		str	r3, [r7, #12]
1183:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_ONEBIT), tmpreg);
 2683              		.loc 1 1183 3
 2684 007e 7B68     		ldr	r3, [r7, #4]
 2685 0080 1B68     		ldr	r3, [r3]
 2686 0082 9B68     		ldr	r3, [r3, #8]
 2687 0084 8A4A     		ldr	r2, .L168+8
 2688 0086 1340     		ands	r3, r2
 2689 0088 1900     		movs	r1, r3
 2690 008a 7B68     		ldr	r3, [r7, #4]
 2691 008c 1B68     		ldr	r3, [r3]
 2692 008e FA68     		ldr	r2, [r7, #12]
 2693 0090 0A43     		orrs	r2, r1
 2694 0092 9A60     		str	r2, [r3, #8]
1184:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1185:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /*-------------------------- USART BRR Configuration -----------------------*/
1186:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   UART_GETCLOCKSOURCE(huart, clocksource);
 2695              		.loc 1 1186 3
 2696 0094 874B     		ldr	r3, .L168+12
 2697 0096 1B6B     		ldr	r3, [r3, #48]
 2698 0098 0322     		movs	r2, #3
 2699 009a 1340     		ands	r3, r2
 2700 009c 032B     		cmp	r3, #3
 2701 009e 0DD0     		beq	.L148
 2702 00a0 1BD8     		bhi	.L149
 2703 00a2 022B     		cmp	r3, #2
 2704 00a4 14D0     		beq	.L150
 2705 00a6 18D8     		bhi	.L149
 2706 00a8 002B     		cmp	r3, #0
 2707 00aa 02D0     		beq	.L151
 2708 00ac 012B     		cmp	r3, #1
 2709 00ae 0AD0     		beq	.L152
 2710 00b0 13E0     		b	.L149
 2711              	.L151:
 2712              		.loc 1 1186 3 is_stmt 0 discriminator 2
 2713 00b2 1723     		movs	r3, #23
 2714 00b4 FB18     		adds	r3, r7, r3
 2715 00b6 0022     		movs	r2, #0
 2716 00b8 1A70     		strb	r2, [r3]
 2717 00ba 13E0     		b	.L153
 2718              	.L148:
 2719              		.loc 1 1186 3 discriminator 5
 2720 00bc 1723     		movs	r3, #23
 2721 00be FB18     		adds	r3, r7, r3
 2722 00c0 0222     		movs	r2, #2
 2723 00c2 1A70     		strb	r2, [r3]
 2724 00c4 0EE0     		b	.L153
 2725              	.L152:
 2726              		.loc 1 1186 3 discriminator 3
 2727 00c6 1723     		movs	r3, #23
 2728 00c8 FB18     		adds	r3, r7, r3
 2729 00ca 0422     		movs	r2, #4
 2730 00cc 1A70     		strb	r2, [r3]
 2731 00ce 09E0     		b	.L153
 2732              	.L150:
 2733              		.loc 1 1186 3 discriminator 4
 2734 00d0 1723     		movs	r3, #23
 2735 00d2 FB18     		adds	r3, r7, r3
 2736 00d4 0822     		movs	r2, #8
 2737 00d6 1A70     		strb	r2, [r3]
 2738 00d8 04E0     		b	.L153
 2739              	.L149:
 2740              		.loc 1 1186 3 discriminator 1
 2741 00da 1723     		movs	r3, #23
 2742 00dc FB18     		adds	r3, r7, r3
 2743 00de 1022     		movs	r2, #16
 2744 00e0 1A70     		strb	r2, [r3]
 2745 00e2 C046     		nop
 2746              	.L153:
1187:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   
1188:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check UART Over Sampling to set Baud Rate Register */
1189:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 2747              		.loc 1 1189 18 is_stmt 1
 2748 00e4 7B68     		ldr	r3, [r7, #4]
 2749 00e6 DA69     		ldr	r2, [r3, #28]
 2750              		.loc 1 1189 6
 2751 00e8 8023     		movs	r3, #128
 2752 00ea 1B02     		lsls	r3, r3, #8
 2753 00ec 9A42     		cmp	r2, r3
 2754 00ee 00D0     		beq	.LCB2354
 2755 00f0 77E0     		b	.L154	@long jump
 2756              	.LCB2354:
1190:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1191:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     switch (clocksource)
 2757              		.loc 1 1191 5
 2758 00f2 1723     		movs	r3, #23
 2759 00f4 FB18     		adds	r3, r7, r3
 2760 00f6 1B78     		ldrb	r3, [r3]
 2761 00f8 082B     		cmp	r3, #8
 2762 00fa 41D0     		beq	.L155
 2763 00fc 52DC     		bgt	.L156
 2764 00fe 042B     		cmp	r3, #4
 2765 0100 2AD0     		beq	.L157
 2766 0102 4FDC     		bgt	.L156
 2767 0104 002B     		cmp	r3, #0
 2768 0106 02D0     		beq	.L158
 2769 0108 022B     		cmp	r3, #2
 2770 010a 14D0     		beq	.L159
 2771 010c 4AE0     		b	.L156
 2772              	.L158:
1192:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1193:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_PCLK1:
1194:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 2773              		.loc 1 1194 31
 2774 010e FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2775 0112 0300     		movs	r3, r0
 2776 0114 5A00     		lsls	r2, r3, #1
 2777 0116 7B68     		ldr	r3, [r7, #4]
 2778 0118 5B68     		ldr	r3, [r3, #4]
 2779 011a 5B08     		lsrs	r3, r3, #1
 2780 011c D218     		adds	r2, r2, r3
 2781 011e 7B68     		ldr	r3, [r7, #4]
 2782 0120 5B68     		ldr	r3, [r3, #4]
 2783 0122 1900     		movs	r1, r3
 2784 0124 1000     		movs	r0, r2
 2785 0126 FFF7FEFF 		bl	__aeabi_uidiv
 2786 012a 0300     		movs	r3, r0
 2787 012c 1A00     		movs	r2, r3
 2788              		.loc 1 1194 18
 2789 012e 1423     		movs	r3, #20
 2790 0130 FB18     		adds	r3, r7, r3
 2791 0132 1A80     		strh	r2, [r3]
1195:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2792              		.loc 1 1195 9
 2793 0134 3BE0     		b	.L160
 2794              	.L159:
1196:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_HSI:
1197:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 2795              		.loc 1 1197 31
 2796 0136 7B68     		ldr	r3, [r7, #4]
 2797 0138 5B68     		ldr	r3, [r3, #4]
 2798 013a 5B08     		lsrs	r3, r3, #1
 2799 013c 5E4A     		ldr	r2, .L168+16
 2800 013e 9A18     		adds	r2, r3, r2
 2801 0140 7B68     		ldr	r3, [r7, #4]
 2802 0142 5B68     		ldr	r3, [r3, #4]
 2803 0144 1900     		movs	r1, r3
 2804 0146 1000     		movs	r0, r2
 2805 0148 FFF7FEFF 		bl	__aeabi_uidiv
 2806 014c 0300     		movs	r3, r0
 2807 014e 1A00     		movs	r2, r3
 2808              		.loc 1 1197 18
 2809 0150 1423     		movs	r3, #20
 2810 0152 FB18     		adds	r3, r7, r3
 2811 0154 1A80     		strh	r2, [r3]
1198:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2812              		.loc 1 1198 9
 2813 0156 2AE0     		b	.L160
 2814              	.L157:
1199:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_SYSCLK:
1200:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 2815              		.loc 1 1200 31
 2816 0158 FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2817 015c 0300     		movs	r3, r0
 2818 015e 5A00     		lsls	r2, r3, #1
 2819 0160 7B68     		ldr	r3, [r7, #4]
 2820 0162 5B68     		ldr	r3, [r3, #4]
 2821 0164 5B08     		lsrs	r3, r3, #1
 2822 0166 D218     		adds	r2, r2, r3
 2823 0168 7B68     		ldr	r3, [r7, #4]
 2824 016a 5B68     		ldr	r3, [r3, #4]
 2825 016c 1900     		movs	r1, r3
 2826 016e 1000     		movs	r0, r2
 2827 0170 FFF7FEFF 		bl	__aeabi_uidiv
 2828 0174 0300     		movs	r3, r0
 2829 0176 1A00     		movs	r2, r3
 2830              		.loc 1 1200 18
 2831 0178 1423     		movs	r3, #20
 2832 017a FB18     		adds	r3, r7, r3
 2833 017c 1A80     		strh	r2, [r3]
1201:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2834              		.loc 1 1201 9
 2835 017e 16E0     		b	.L160
 2836              	.L155:
1202:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_LSE:
1203:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 2837              		.loc 1 1203 31
 2838 0180 7B68     		ldr	r3, [r7, #4]
 2839 0182 5B68     		ldr	r3, [r3, #4]
 2840 0184 5B08     		lsrs	r3, r3, #1
 2841 0186 8022     		movs	r2, #128
 2842 0188 5202     		lsls	r2, r2, #9
 2843 018a 9A18     		adds	r2, r3, r2
 2844 018c 7B68     		ldr	r3, [r7, #4]
 2845 018e 5B68     		ldr	r3, [r3, #4]
 2846 0190 1900     		movs	r1, r3
 2847 0192 1000     		movs	r0, r2
 2848 0194 FFF7FEFF 		bl	__aeabi_uidiv
 2849 0198 0300     		movs	r3, r0
 2850 019a 1A00     		movs	r2, r3
 2851              		.loc 1 1203 18
 2852 019c 1423     		movs	r3, #20
 2853 019e FB18     		adds	r3, r7, r3
 2854 01a0 1A80     		strh	r2, [r3]
1204:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2855              		.loc 1 1204 9
 2856 01a2 04E0     		b	.L160
 2857              	.L156:
1205:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1206:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       default:
1207:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         ret = HAL_ERROR;
 2858              		.loc 1 1207 13
 2859 01a4 1323     		movs	r3, #19
 2860 01a6 FB18     		adds	r3, r7, r3
 2861 01a8 0122     		movs	r2, #1
 2862 01aa 1A70     		strb	r2, [r3]
1208:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2863              		.loc 1 1208 9
 2864 01ac C046     		nop
 2865              	.L160:
1209:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1210:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1211:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     brrtemp = usartdiv & 0xFFF0U;
 2866              		.loc 1 1211 13
 2867 01ae 0A20     		movs	r0, #10
 2868 01b0 3B18     		adds	r3, r7, r0
 2869 01b2 1424     		movs	r4, #20
 2870 01b4 3A19     		adds	r2, r7, r4
 2871 01b6 1288     		ldrh	r2, [r2]
 2872 01b8 0F21     		movs	r1, #15
 2873 01ba 8A43     		bics	r2, r1
 2874 01bc 1A80     		strh	r2, [r3]
1212:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 2875              		.loc 1 1212 58
 2876 01be 3B19     		adds	r3, r7, r4
 2877 01c0 1B88     		ldrh	r3, [r3]
 2878 01c2 5B10     		asrs	r3, r3, #1
 2879              		.loc 1 1212 16
 2880 01c4 9BB2     		uxth	r3, r3
 2881 01c6 0722     		movs	r2, #7
 2882 01c8 1340     		ands	r3, r2
 2883 01ca 99B2     		uxth	r1, r3
 2884              		.loc 1 1212 13
 2885 01cc 3B18     		adds	r3, r7, r0
 2886 01ce 3A18     		adds	r2, r7, r0
 2887 01d0 1288     		ldrh	r2, [r2]
 2888 01d2 0A43     		orrs	r2, r1
 2889 01d4 1A80     		strh	r2, [r3]
1213:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->Instance->BRR = brrtemp;
 2890              		.loc 1 1213 10
 2891 01d6 7B68     		ldr	r3, [r7, #4]
 2892 01d8 1B68     		ldr	r3, [r3]
 2893              		.loc 1 1213 26
 2894 01da 3A18     		adds	r2, r7, r0
 2895 01dc 1288     		ldrh	r2, [r2]
 2896 01de DA60     		str	r2, [r3, #12]
 2897 01e0 5BE0     		b	.L161
 2898              	.L154:
1214:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1215:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1216:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1217:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     switch (clocksource)
 2899              		.loc 1 1217 5
 2900 01e2 1723     		movs	r3, #23
 2901 01e4 FB18     		adds	r3, r7, r3
 2902 01e6 1B78     		ldrb	r3, [r3]
 2903 01e8 082B     		cmp	r3, #8
 2904 01ea 3FD0     		beq	.L162
 2905 01ec 50DC     		bgt	.L163
 2906 01ee 042B     		cmp	r3, #4
 2907 01f0 29D0     		beq	.L164
 2908 01f2 4DDC     		bgt	.L163
 2909 01f4 002B     		cmp	r3, #0
 2910 01f6 02D0     		beq	.L165
 2911 01f8 022B     		cmp	r3, #2
 2912 01fa 13D0     		beq	.L166
 2913 01fc 48E0     		b	.L163
 2914              	.L165:
1218:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1219:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_PCLK1:
1220:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.B
 2915              		.loc 1 1220 43
 2916 01fe FFF7FEFF 		bl	HAL_RCC_GetPCLK1Freq
 2917 0202 0200     		movs	r2, r0
 2918 0204 7B68     		ldr	r3, [r7, #4]
 2919 0206 5B68     		ldr	r3, [r3, #4]
 2920 0208 5B08     		lsrs	r3, r3, #1
 2921 020a D218     		adds	r2, r2, r3
 2922 020c 7B68     		ldr	r3, [r7, #4]
 2923 020e 5B68     		ldr	r3, [r3, #4]
 2924 0210 1900     		movs	r1, r3
 2925 0212 1000     		movs	r0, r2
 2926 0214 FFF7FEFF 		bl	__aeabi_uidiv
 2927 0218 0300     		movs	r3, r0
 2928              		.loc 1 1220 32
 2929 021a 9AB2     		uxth	r2, r3
 2930              		.loc 1 1220 14
 2931 021c 7B68     		ldr	r3, [r7, #4]
 2932 021e 1B68     		ldr	r3, [r3]
 2933              		.loc 1 1220 30
 2934 0220 DA60     		str	r2, [r3, #12]
1221:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2935              		.loc 1 1221 9
 2936 0222 3AE0     		b	.L161
 2937              	.L166:
1222:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_HSI:
1223:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 2938              		.loc 1 1223 43
 2939 0224 7B68     		ldr	r3, [r7, #4]
 2940 0226 5B68     		ldr	r3, [r3, #4]
 2941 0228 5B08     		lsrs	r3, r3, #1
 2942 022a 244A     		ldr	r2, .L168+20
 2943 022c 9A18     		adds	r2, r3, r2
 2944 022e 7B68     		ldr	r3, [r7, #4]
 2945 0230 5B68     		ldr	r3, [r3, #4]
 2946 0232 1900     		movs	r1, r3
 2947 0234 1000     		movs	r0, r2
 2948 0236 FFF7FEFF 		bl	__aeabi_uidiv
 2949 023a 0300     		movs	r3, r0
 2950              		.loc 1 1223 32
 2951 023c 9AB2     		uxth	r2, r3
 2952              		.loc 1 1223 14
 2953 023e 7B68     		ldr	r3, [r7, #4]
 2954 0240 1B68     		ldr	r3, [r3]
 2955              		.loc 1 1223 30
 2956 0242 DA60     		str	r2, [r3, #12]
1224:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2957              		.loc 1 1224 9
 2958 0244 29E0     		b	.L161
 2959              	.L164:
1225:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_SYSCLK:
1226:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Ini
 2960              		.loc 1 1226 43
 2961 0246 FFF7FEFF 		bl	HAL_RCC_GetSysClockFreq
 2962 024a 0200     		movs	r2, r0
 2963 024c 7B68     		ldr	r3, [r7, #4]
 2964 024e 5B68     		ldr	r3, [r3, #4]
 2965 0250 5B08     		lsrs	r3, r3, #1
 2966 0252 D218     		adds	r2, r2, r3
 2967 0254 7B68     		ldr	r3, [r7, #4]
 2968 0256 5B68     		ldr	r3, [r3, #4]
 2969 0258 1900     		movs	r1, r3
 2970 025a 1000     		movs	r0, r2
 2971 025c FFF7FEFF 		bl	__aeabi_uidiv
 2972 0260 0300     		movs	r3, r0
 2973              		.loc 1 1226 32
 2974 0262 9AB2     		uxth	r2, r3
 2975              		.loc 1 1226 14
 2976 0264 7B68     		ldr	r3, [r7, #4]
 2977 0266 1B68     		ldr	r3, [r3]
 2978              		.loc 1 1226 30
 2979 0268 DA60     		str	r2, [r3, #12]
1227:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 2980              		.loc 1 1227 9
 2981 026a 16E0     		b	.L161
 2982              	.L162:
1228:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_LSE:
1229:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->BRR = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 2983              		.loc 1 1229 43
 2984 026c 7B68     		ldr	r3, [r7, #4]
 2985 026e 5B68     		ldr	r3, [r3, #4]
 2986 0270 5B08     		lsrs	r3, r3, #1
 2987 0272 8022     		movs	r2, #128
 2988 0274 1202     		lsls	r2, r2, #8
 2989 0276 9A18     		adds	r2, r3, r2
 2990 0278 7B68     		ldr	r3, [r7, #4]
 2991 027a 5B68     		ldr	r3, [r3, #4]
 2992 027c 1900     		movs	r1, r3
 2993 027e 1000     		movs	r0, r2
 2994 0280 FFF7FEFF 		bl	__aeabi_uidiv
 2995 0284 0300     		movs	r3, r0
 2996              		.loc 1 1229 32
 2997 0286 9AB2     		uxth	r2, r3
 2998              		.loc 1 1229 14
 2999 0288 7B68     		ldr	r3, [r7, #4]
 3000 028a 1B68     		ldr	r3, [r3]
 3001              		.loc 1 1229 30
 3002 028c DA60     		str	r2, [r3, #12]
1230:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 3003              		.loc 1 1230 9
 3004 028e 04E0     		b	.L161
 3005              	.L163:
1231:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       case UART_CLOCKSOURCE_UNDEFINED:
1232:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       default:
1233:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         ret = HAL_ERROR;
 3006              		.loc 1 1233 13
 3007 0290 1323     		movs	r3, #19
 3008 0292 FB18     		adds	r3, r7, r3
 3009 0294 0122     		movs	r2, #1
 3010 0296 1A70     		strb	r2, [r3]
1234:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         break;
 3011              		.loc 1 1234 9
 3012 0298 C046     		nop
 3013              	.L161:
1235:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1236:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1237:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1238:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return ret;
 3014              		.loc 1 1238 10
 3015 029a 1323     		movs	r3, #19
 3016 029c FB18     		adds	r3, r7, r3
 3017 029e 1B78     		ldrb	r3, [r3]
1239:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1240:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3018              		.loc 1 1240 1
 3019 02a0 1800     		movs	r0, r3
 3020 02a2 BD46     		mov	sp, r7
 3021 02a4 07B0     		add	sp, sp, #28
 3022              		@ sp needed
 3023 02a6 90BD     		pop	{r4, r7, pc}
 3024              	.L169:
 3025              		.align	2
 3026              	.L168:
 3027 02a8 F369FFFF 		.word	-38413
 3028 02ac FFCFFFFF 		.word	-12289
 3029 02b0 FFF4FFFF 		.word	-2817
 3030 02b4 00100240 		.word	1073876992
 3031 02b8 0048E801 		.word	32000000
 3032 02bc 0024F400 		.word	16000000
 3033              		.cfi_endproc
 3034              	.LFE48:
 3036              		.section	.text.HAL_UART_Init,"ax",%progbits
 3037              		.align	1
 3038              		.global	HAL_UART_Init
 3039              		.syntax unified
 3040              		.code	16
 3041              		.thumb_func
 3042              		.fpu softvfp
 3044              	HAL_UART_Init:
 3045              	.LFB49:
1241:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1242:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1243:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Initialize the UART mode according to the specified
1244:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *        parameters in the UART_InitTypeDef and initialize the associated handle.
1245:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1246:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1247:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1248:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
1249:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 3046              		.loc 1 1249 1
 3047              		.cfi_startproc
 3048              		@ args = 0, pretend = 0, frame = 8
 3049              		@ frame_needed = 1, uses_anonymous_args = 0
 3050 0000 80B5     		push	{r7, lr}
 3051              	.LCFI32:
 3052              		.cfi_def_cfa_offset 8
 3053              		.cfi_offset 7, -8
 3054              		.cfi_offset 14, -4
 3055 0002 82B0     		sub	sp, sp, #8
 3056              	.LCFI33:
 3057              		.cfi_def_cfa_offset 16
 3058 0004 00AF     		add	r7, sp, #0
 3059              	.LCFI34:
 3060              		.cfi_def_cfa_register 7
 3061 0006 7860     		str	r0, [r7, #4]
1250:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check the UART handle allocation */
1251:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart == NULL)
 3062              		.loc 1 1251 5
 3063 0008 7B68     		ldr	r3, [r7, #4]
 3064 000a 002B     		cmp	r3, #0
 3065 000c 01D1     		bne	.L171
1252:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1253:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_ERROR;
 3066              		.loc 1 1253 12
 3067 000e 0123     		movs	r3, #1
 3068 0010 3BE0     		b	.L172
 3069              	.L171:
1254:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1255:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1256:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
1257:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1258:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
1259:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
1260:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1261:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1262:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1263:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Check the parameters */
1264:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     assert_param(IS_UART_INSTANCE(huart->Instance));
1265:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1266:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1267:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->gState == HAL_UART_STATE_RESET)
 3070              		.loc 1 1267 11
 3071 0012 7B68     		ldr	r3, [r7, #4]
 3072 0014 6922     		movs	r2, #105
 3073 0016 9B5C     		ldrb	r3, [r3, r2]
 3074 0018 DBB2     		uxtb	r3, r3
 3075              		.loc 1 1267 5
 3076 001a 002B     		cmp	r3, #0
 3077 001c 03D1     		bne	.L173
1268:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1269:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Allocate lock resource and initialize it */
1270:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->Lock = HAL_UNLOCKED;
 3078              		.loc 1 1270 17
 3079 001e 7B68     		ldr	r3, [r7, #4]
 3080 0020 6822     		movs	r2, #104
 3081 0022 0021     		movs	r1, #0
 3082 0024 9954     		strb	r1, [r3, r2]
 3083              	.L173:
1271:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1272:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init the low level hardware : GPIO, CLOCK */
1273:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     //HAL_UART_MspInit(huart);
1274:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1275:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1276:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   huart->gState = HAL_UART_STATE_BUSY;
 3084              		.loc 1 1276 17
 3085 0026 7B68     		ldr	r3, [r7, #4]
 3086 0028 6922     		movs	r2, #105
 3087 002a 2421     		movs	r1, #36
 3088 002c 9954     		strb	r1, [r3, r2]
1277:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1278:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Disable the Peripheral */
1279:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UART_DISABLE(huart);
 3089              		.loc 1 1279 3
 3090 002e 7B68     		ldr	r3, [r7, #4]
 3091 0030 1B68     		ldr	r3, [r3]
 3092 0032 1A68     		ldr	r2, [r3]
 3093 0034 7B68     		ldr	r3, [r7, #4]
 3094 0036 1B68     		ldr	r3, [r3]
 3095 0038 0121     		movs	r1, #1
 3096 003a 8A43     		bics	r2, r1
 3097 003c 1A60     		str	r2, [r3]
1280:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1281:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Set the UART Communication parameters */
1282:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (UART_SetConfig(huart) == HAL_ERROR)
 3098              		.loc 1 1282 7
 3099 003e 7B68     		ldr	r3, [r7, #4]
 3100 0040 1800     		movs	r0, r3
 3101 0042 FFF7FEFF 		bl	UART_SetConfig
 3102 0046 0300     		movs	r3, r0
 3103              		.loc 1 1282 6
 3104 0048 012B     		cmp	r3, #1
 3105 004a 01D1     		bne	.L174
1283:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1284:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_ERROR;
 3106              		.loc 1 1284 12
 3107 004c 0123     		movs	r3, #1
 3108 004e 1CE0     		b	.L172
 3109              	.L174:
1285:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1286:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1287:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
1288:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1289:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     //UART_AdvFeatureConfig(huart);
1290:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1291:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1292:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* In asynchronous mode, the following bits must be kept cleared:
1293:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   - LINEN (if LIN is supported) and CLKEN bits in the USART_CR2 register,
1294:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   - SCEN (if Smartcard is supported), HDSEL and IREN (if IrDA is supported)  bits in the USART_CR3 
1295:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR2_LINEN)
1296:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
1297:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1298:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 3110              		.loc 1 1298 3
 3111 0050 7B68     		ldr	r3, [r7, #4]
 3112 0052 1B68     		ldr	r3, [r3]
 3113 0054 5A68     		ldr	r2, [r3, #4]
 3114 0056 7B68     		ldr	r3, [r7, #4]
 3115 0058 1B68     		ldr	r3, [r3]
 3116 005a 0E49     		ldr	r1, .L175
 3117 005c 0A40     		ands	r2, r1
 3118 005e 5A60     		str	r2, [r3, #4]
1299:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1300:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_SCEN)
1301:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_IREN)
1302:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
1303:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1304:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL));
1305:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1306:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1307:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #if defined (USART_CR3_IREN)
1308:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN));
1309:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #else
1310:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 3119              		.loc 1 1310 3
 3120 0060 7B68     		ldr	r3, [r7, #4]
 3121 0062 1B68     		ldr	r3, [r3]
 3122 0064 9A68     		ldr	r2, [r3, #8]
 3123 0066 7B68     		ldr	r3, [r7, #4]
 3124 0068 1B68     		ldr	r3, [r3]
 3125 006a 0821     		movs	r1, #8
 3126 006c 8A43     		bics	r2, r1
 3127 006e 9A60     		str	r2, [r3, #8]
1311:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1312:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** #endif
1313:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1314:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Enable the Peripheral */
1315:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   __HAL_UART_ENABLE(huart);
 3128              		.loc 1 1315 3
 3129 0070 7B68     		ldr	r3, [r7, #4]
 3130 0072 1B68     		ldr	r3, [r3]
 3131 0074 1A68     		ldr	r2, [r3]
 3132 0076 7B68     		ldr	r3, [r7, #4]
 3133 0078 1B68     		ldr	r3, [r3]
 3134 007a 0121     		movs	r1, #1
 3135 007c 0A43     		orrs	r2, r1
 3136 007e 1A60     		str	r2, [r3]
1316:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1317:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
1318:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   return (UART_CheckIdleState(huart));
 3137              		.loc 1 1318 11
 3138 0080 7B68     		ldr	r3, [r7, #4]
 3139 0082 1800     		movs	r0, r3
 3140 0084 FFF7FEFF 		bl	UART_CheckIdleState
 3141 0088 0300     		movs	r3, r0
 3142              	.L172:
1319:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3143              		.loc 1 1319 1
 3144 008a 1800     		movs	r0, r3
 3145 008c BD46     		mov	sp, r7
 3146 008e 02B0     		add	sp, sp, #8
 3147              		@ sp needed
 3148 0090 80BD     		pop	{r7, pc}
 3149              	.L176:
 3150 0092 C046     		.align	2
 3151              	.L175:
 3152 0094 FFF7FFFF 		.word	-2049
 3153              		.cfi_endproc
 3154              	.LFE49:
 3156              		.section	.text.HAL_UART_Receive,"ax",%progbits
 3157              		.align	1
 3158              		.global	HAL_UART_Receive
 3159              		.syntax unified
 3160              		.code	16
 3161              		.thumb_func
 3162              		.fpu softvfp
 3164              	HAL_UART_Receive:
 3165              	.LFB50:
1320:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1321:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1322:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Receive an amount of data in blocking mode.
1323:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1324:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param pData: pointer to data buffer.
1325:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Size: amount of data to be received.
1326:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Timeout: Timeout duration.
1327:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-
1328:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         address of user data buffer for storing data to be received, should be aligned on a hal
1329:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (as received data will be handled using u16 pointer cast). Depending on compilation cha
1330:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         use of specific alignment compilation directives or pragmas might be required to ensure
1331:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1332:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1333:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32
1334:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 3166              		.loc 1 1334 1
 3167              		.cfi_startproc
 3168              		@ args = 0, pretend = 0, frame = 32
 3169              		@ frame_needed = 1, uses_anonymous_args = 0
 3170 0000 80B5     		push	{r7, lr}
 3171              	.LCFI35:
 3172              		.cfi_def_cfa_offset 8
 3173              		.cfi_offset 7, -8
 3174              		.cfi_offset 14, -4
 3175 0002 8AB0     		sub	sp, sp, #40
 3176              	.LCFI36:
 3177              		.cfi_def_cfa_offset 48
 3178 0004 02AF     		add	r7, sp, #8
 3179              	.LCFI37:
 3180              		.cfi_def_cfa 7, 40
 3181 0006 F860     		str	r0, [r7, #12]
 3182 0008 B960     		str	r1, [r7, #8]
 3183 000a 3B60     		str	r3, [r7]
 3184 000c BB1D     		adds	r3, r7, #6
 3185 000e 1A80     		strh	r2, [r3]
1335:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t* tmp;
1336:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t uhMask;
1337:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0;
 3186              		.loc 1 1337 12
 3187 0010 0023     		movs	r3, #0
 3188 0012 FB61     		str	r3, [r7, #28]
1338:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1339:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check that a Rx process is not already ongoing */
1340:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->RxState == HAL_UART_STATE_READY)
 3189              		.loc 1 1340 11
 3190 0014 FB68     		ldr	r3, [r7, #12]
 3191 0016 6A22     		movs	r2, #106
 3192 0018 9B5C     		ldrb	r3, [r3, r2]
 3193 001a DBB2     		uxtb	r3, r3
 3194              		.loc 1 1340 5
 3195 001c 202B     		cmp	r3, #32
 3196 001e 00D0     		beq	.LCB2759
 3197 0020 B4E0     		b	.L178	@long jump
 3198              	.LCB2759:
1341:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1342:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((pData == NULL ) || (Size == 0U))
 3199              		.loc 1 1342 7
 3200 0022 BB68     		ldr	r3, [r7, #8]
 3201 0024 002B     		cmp	r3, #0
 3202 0026 03D0     		beq	.L179
 3203              		.loc 1 1342 25 discriminator 1
 3204 0028 BB1D     		adds	r3, r7, #6
 3205 002a 1B88     		ldrh	r3, [r3]
 3206 002c 002B     		cmp	r3, #0
 3207 002e 01D1     		bne	.L180
 3208              	.L179:
1343:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1344:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return  HAL_ERROR;
 3209              		.loc 1 1344 15
 3210 0030 0123     		movs	r3, #1
 3211 0032 ACE0     		b	.L181
 3212              	.L180:
1345:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1346:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1347:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
1348:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        should be aligned on a u16 frontier, as data to be received from RDR will be 
1349:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        handled through a u16 cast. */
1350:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 3213              		.loc 1 1350 21
 3214 0034 FB68     		ldr	r3, [r7, #12]
 3215 0036 9A68     		ldr	r2, [r3, #8]
 3216              		.loc 1 1350 8
 3217 0038 8023     		movs	r3, #128
 3218 003a 5B01     		lsls	r3, r3, #5
 3219 003c 9A42     		cmp	r2, r3
 3220 003e 09D1     		bne	.L182
 3221              		.loc 1 1350 71 discriminator 1
 3222 0040 FB68     		ldr	r3, [r7, #12]
 3223 0042 1B69     		ldr	r3, [r3, #16]
 3224              		.loc 1 1350 56 discriminator 1
 3225 0044 002B     		cmp	r3, #0
 3226 0046 05D1     		bne	.L182
1351:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1352:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((((uint32_t)pData)&1U) != 0U)
 3227              		.loc 1 1352 12
 3228 0048 BB68     		ldr	r3, [r7, #8]
 3229              		.loc 1 1352 28
 3230 004a 0122     		movs	r2, #1
 3231 004c 1340     		ands	r3, r2
 3232              		.loc 1 1352 9
 3233 004e 01D0     		beq	.L182
1353:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1354:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return  HAL_ERROR;
 3234              		.loc 1 1354 17
 3235 0050 0123     		movs	r3, #1
 3236 0052 9CE0     		b	.L181
 3237              	.L182:
1355:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1356:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1357:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1358:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Locked */
1359:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_LOCK(huart);
 3238              		.loc 1 1359 5
 3239 0054 FB68     		ldr	r3, [r7, #12]
 3240 0056 6822     		movs	r2, #104
 3241 0058 9B5C     		ldrb	r3, [r3, r2]
 3242 005a 012B     		cmp	r3, #1
 3243 005c 01D1     		bne	.L183
 3244              		.loc 1 1359 5 is_stmt 0 discriminator 1
 3245 005e 0223     		movs	r3, #2
 3246 0060 95E0     		b	.L181
 3247              	.L183:
 3248              		.loc 1 1359 5 discriminator 2
 3249 0062 FB68     		ldr	r3, [r7, #12]
 3250 0064 6822     		movs	r2, #104
 3251 0066 0121     		movs	r1, #1
 3252 0068 9954     		strb	r1, [r3, r2]
1360:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1361:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 3253              		.loc 1 1361 22 is_stmt 1 discriminator 2
 3254 006a FB68     		ldr	r3, [r7, #12]
 3255 006c 0022     		movs	r2, #0
 3256 006e DA66     		str	r2, [r3, #108]
1362:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxState = HAL_UART_STATE_BUSY_RX;
 3257              		.loc 1 1362 20 discriminator 2
 3258 0070 FB68     		ldr	r3, [r7, #12]
 3259 0072 6A22     		movs	r2, #106
 3260 0074 2221     		movs	r1, #34
 3261 0076 9954     		strb	r1, [r3, r2]
1363:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1364:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init tickstart for timeout managment*/
1365:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 3262              		.loc 1 1365 17 discriminator 2
 3263 0078 FFF7FEFF 		bl	HAL_GetTick
 3264 007c 0300     		movs	r3, r0
 3265 007e FB61     		str	r3, [r7, #28]
1366:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1367:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxXferSize = Size;
 3266              		.loc 1 1367 23 discriminator 2
 3267 0080 FB68     		ldr	r3, [r7, #12]
 3268 0082 BA1D     		adds	r2, r7, #6
 3269 0084 5821     		movs	r1, #88
 3270 0086 1288     		ldrh	r2, [r2]
 3271 0088 5A52     		strh	r2, [r3, r1]
1368:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxXferCount = Size;
 3272              		.loc 1 1368 24 discriminator 2
 3273 008a FB68     		ldr	r3, [r7, #12]
 3274 008c BA1D     		adds	r2, r7, #6
 3275 008e 5A21     		movs	r1, #90
 3276 0090 1288     		ldrh	r2, [r2]
 3277 0092 5A52     		strh	r2, [r3, r1]
1369:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1370:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Computation of UART mask to apply to RDR register */
1371:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     UART_MASK_COMPUTATION(huart);
 3278              		.loc 1 1371 5 discriminator 2
 3279 0094 FB68     		ldr	r3, [r7, #12]
 3280 0096 9A68     		ldr	r2, [r3, #8]
 3281 0098 8023     		movs	r3, #128
 3282 009a 5B01     		lsls	r3, r3, #5
 3283 009c 9A42     		cmp	r2, r3
 3284 009e 0DD1     		bne	.L184
 3285              		.loc 1 1371 5 is_stmt 0 discriminator 1
 3286 00a0 FB68     		ldr	r3, [r7, #12]
 3287 00a2 1B69     		ldr	r3, [r3, #16]
 3288 00a4 002B     		cmp	r3, #0
 3289 00a6 04D1     		bne	.L185
 3290              		.loc 1 1371 5 discriminator 3
 3291 00a8 FB68     		ldr	r3, [r7, #12]
 3292 00aa 5C22     		movs	r2, #92
 3293 00ac 3A49     		ldr	r1, .L192
 3294 00ae 9952     		strh	r1, [r3, r2]
 3295 00b0 15E0     		b	.L186
 3296              	.L185:
 3297              		.loc 1 1371 5 discriminator 4
 3298 00b2 FB68     		ldr	r3, [r7, #12]
 3299 00b4 5C22     		movs	r2, #92
 3300 00b6 FF21     		movs	r1, #255
 3301 00b8 9952     		strh	r1, [r3, r2]
 3302 00ba 10E0     		b	.L186
 3303              	.L184:
 3304              		.loc 1 1371 5 discriminator 2
 3305 00bc FB68     		ldr	r3, [r7, #12]
 3306 00be 9B68     		ldr	r3, [r3, #8]
 3307 00c0 002B     		cmp	r3, #0
 3308 00c2 0CD1     		bne	.L186
 3309              		.loc 1 1371 5 discriminator 5
 3310 00c4 FB68     		ldr	r3, [r7, #12]
 3311 00c6 1B69     		ldr	r3, [r3, #16]
 3312 00c8 002B     		cmp	r3, #0
 3313 00ca 04D1     		bne	.L187
 3314              		.loc 1 1371 5 discriminator 6
 3315 00cc FB68     		ldr	r3, [r7, #12]
 3316 00ce 5C22     		movs	r2, #92
 3317 00d0 FF21     		movs	r1, #255
 3318 00d2 9952     		strh	r1, [r3, r2]
 3319 00d4 03E0     		b	.L186
 3320              	.L187:
 3321              		.loc 1 1371 5 discriminator 7
 3322 00d6 FB68     		ldr	r3, [r7, #12]
 3323 00d8 5C22     		movs	r2, #92
 3324 00da 7F21     		movs	r1, #127
 3325 00dc 9952     		strh	r1, [r3, r2]
 3326              	.L186:
1372:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     uhMask = huart->Mask;
 3327              		.loc 1 1372 12 is_stmt 1
 3328 00de 1A23     		movs	r3, #26
 3329 00e0 FB18     		adds	r3, r7, r3
 3330 00e2 FA68     		ldr	r2, [r7, #12]
 3331 00e4 5C21     		movs	r1, #92
 3332 00e6 525A     		ldrh	r2, [r2, r1]
 3333 00e8 1A80     		strh	r2, [r3]
1373:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1374:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* as long as data have to be received */
1375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     while(huart->RxXferCount > 0U)
 3334              		.loc 1 1375 10
 3335 00ea 3FE0     		b	.L188
 3336              	.L191:
1376:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1377:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       huart->RxXferCount--;
 3337              		.loc 1 1377 12
 3338 00ec FB68     		ldr	r3, [r7, #12]
 3339 00ee 5A22     		movs	r2, #90
 3340 00f0 9B5A     		ldrh	r3, [r3, r2]
 3341 00f2 9BB2     		uxth	r3, r3
 3342              		.loc 1 1377 25
 3343 00f4 013B     		subs	r3, r3, #1
 3344 00f6 99B2     		uxth	r1, r3
 3345 00f8 FB68     		ldr	r3, [r7, #12]
 3346 00fa 5A22     		movs	r2, #90
 3347 00fc 9952     		strh	r1, [r3, r2]
1378:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 3348              		.loc 1 1378 10
 3349 00fe FA69     		ldr	r2, [r7, #28]
 3350 0100 F868     		ldr	r0, [r7, #12]
 3351 0102 3B68     		ldr	r3, [r7]
 3352 0104 0093     		str	r3, [sp]
 3353 0106 1300     		movs	r3, r2
 3354 0108 0022     		movs	r2, #0
 3355 010a 2021     		movs	r1, #32
 3356 010c FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3357 0110 031E     		subs	r3, r0, #0
 3358              		.loc 1 1378 9
 3359 0112 01D0     		beq	.L189
1379:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1380:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 3360              		.loc 1 1380 16
 3361 0114 0323     		movs	r3, #3
 3362 0116 3AE0     		b	.L181
 3363              	.L189:
1381:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1382:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 3364              		.loc 1 1382 23
 3365 0118 FB68     		ldr	r3, [r7, #12]
 3366 011a 9A68     		ldr	r2, [r3, #8]
 3367              		.loc 1 1382 10
 3368 011c 8023     		movs	r3, #128
 3369 011e 5B01     		lsls	r3, r3, #5
 3370 0120 9A42     		cmp	r2, r3
 3371 0122 14D1     		bne	.L190
 3372              		.loc 1 1382 73 discriminator 1
 3373 0124 FB68     		ldr	r3, [r7, #12]
 3374 0126 1B69     		ldr	r3, [r3, #16]
 3375              		.loc 1 1382 58 discriminator 1
 3376 0128 002B     		cmp	r3, #0
 3377 012a 10D1     		bne	.L190
1383:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1384:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tmp = (uint16_t*) pData ;
 3378              		.loc 1 1384 13
 3379 012c BB68     		ldr	r3, [r7, #8]
 3380 012e 7B61     		str	r3, [r7, #20]
1385:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         *tmp = (uint16_t)(huart->Instance->RDR & uhMask);
 3381              		.loc 1 1385 32
 3382 0130 FB68     		ldr	r3, [r7, #12]
 3383 0132 1B68     		ldr	r3, [r3]
 3384              		.loc 1 1385 42
 3385 0134 9B8C     		ldrh	r3, [r3, #36]
 3386 0136 9BB2     		uxth	r3, r3
 3387              		.loc 1 1385 16
 3388 0138 1A22     		movs	r2, #26
 3389 013a BA18     		adds	r2, r7, r2
 3390 013c 1288     		ldrh	r2, [r2]
 3391 013e 1340     		ands	r3, r2
 3392 0140 9AB2     		uxth	r2, r3
 3393              		.loc 1 1385 14
 3394 0142 7B69     		ldr	r3, [r7, #20]
 3395 0144 1A80     		strh	r2, [r3]
1386:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         pData +=2U;
 3396              		.loc 1 1386 15
 3397 0146 BB68     		ldr	r3, [r7, #8]
 3398 0148 0233     		adds	r3, r3, #2
 3399 014a BB60     		str	r3, [r7, #8]
 3400 014c 0EE0     		b	.L188
 3401              	.L190:
1387:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1388:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
1389:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1390:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         *pData++ = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 3402              		.loc 1 1390 35
 3403 014e FB68     		ldr	r3, [r7, #12]
 3404 0150 1B68     		ldr	r3, [r3]
 3405              		.loc 1 1390 45
 3406 0152 9B8C     		ldrh	r3, [r3, #36]
 3407 0154 9BB2     		uxth	r3, r3
 3408              		.loc 1 1390 20
 3409 0156 DAB2     		uxtb	r2, r3
 3410              		.loc 1 1390 53
 3411 0158 1A23     		movs	r3, #26
 3412 015a FB18     		adds	r3, r7, r3
 3413 015c 1B88     		ldrh	r3, [r3]
 3414 015e D9B2     		uxtb	r1, r3
 3415              		.loc 1 1390 15
 3416 0160 BB68     		ldr	r3, [r7, #8]
 3417 0162 581C     		adds	r0, r3, #1
 3418 0164 B860     		str	r0, [r7, #8]
 3419              		.loc 1 1390 20
 3420 0166 0A40     		ands	r2, r1
 3421 0168 D2B2     		uxtb	r2, r2
 3422              		.loc 1 1390 18
 3423 016a 1A70     		strb	r2, [r3]
 3424              	.L188:
1375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3425              		.loc 1 1375 16
 3426 016c FB68     		ldr	r3, [r7, #12]
 3427 016e 5A22     		movs	r2, #90
 3428 0170 9B5A     		ldrh	r3, [r3, r2]
 3429 0172 9BB2     		uxth	r3, r3
1375:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3430              		.loc 1 1375 30
 3431 0174 002B     		cmp	r3, #0
 3432 0176 B9D1     		bne	.L191
1391:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1392:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1393:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1394:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* At end of Rx process, restore huart->RxState to Ready */
1395:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->RxState = HAL_UART_STATE_READY;
 3433              		.loc 1 1395 20
 3434 0178 FB68     		ldr	r3, [r7, #12]
 3435 017a 6A22     		movs	r2, #106
 3436 017c 2021     		movs	r1, #32
 3437 017e 9954     		strb	r1, [r3, r2]
1396:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1397:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Unlocked */
1398:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_UNLOCK(huart);
 3438              		.loc 1 1398 5
 3439 0180 FB68     		ldr	r3, [r7, #12]
 3440 0182 6822     		movs	r2, #104
 3441 0184 0021     		movs	r1, #0
 3442 0186 9954     		strb	r1, [r3, r2]
1399:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1400:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_OK;
 3443              		.loc 1 1400 12
 3444 0188 0023     		movs	r3, #0
 3445 018a 00E0     		b	.L181
 3446              	.L178:
1401:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1402:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1403:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1404:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_BUSY;
 3447              		.loc 1 1404 12
 3448 018c 0223     		movs	r3, #2
 3449              	.L181:
1405:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1406:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3450              		.loc 1 1406 1
 3451 018e 1800     		movs	r0, r3
 3452 0190 BD46     		mov	sp, r7
 3453 0192 08B0     		add	sp, sp, #32
 3454              		@ sp needed
 3455 0194 80BD     		pop	{r7, pc}
 3456              	.L193:
 3457 0196 C046     		.align	2
 3458              	.L192:
 3459 0198 FF010000 		.word	511
 3460              		.cfi_endproc
 3461              	.LFE50:
 3463              		.section	.text.HAL_UART_Transmit,"ax",%progbits
 3464              		.align	1
 3465              		.global	HAL_UART_Transmit
 3466              		.syntax unified
 3467              		.code	16
 3468              		.thumb_func
 3469              		.fpu softvfp
 3471              	HAL_UART_Transmit:
 3472              	.LFB51:
1407:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1408:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** /**
1409:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @brief Send an amount of data in blocking mode.
1410:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param huart: UART handle.
1411:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param pData: Pointer to data buffer.
1412:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Size: Amount of data to be sent.
1413:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @param Timeout: Timeout duration.
1414:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @note   When UART parity is not enabled (PCE = 0), and Word Length is configured to 9 bits (M1-
1415:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         address of user data buffer containing data to be sent, should be aligned on a half wor
1416:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         (as sent data will be handled using u16 pointer cast). Depending on compilation chain,
1417:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   *         use of specific alignment compilation directives or pragmas might be required to ensure
1418:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   * @retval HAL status
1419:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   */
1420:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint3
1421:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** {
 3473              		.loc 1 1421 1
 3474              		.cfi_startproc
 3475              		@ args = 0, pretend = 0, frame = 24
 3476              		@ frame_needed = 1, uses_anonymous_args = 0
 3477 0000 80B5     		push	{r7, lr}
 3478              	.LCFI38:
 3479              		.cfi_def_cfa_offset 8
 3480              		.cfi_offset 7, -8
 3481              		.cfi_offset 14, -4
 3482 0002 88B0     		sub	sp, sp, #32
 3483              	.LCFI39:
 3484              		.cfi_def_cfa_offset 40
 3485 0004 02AF     		add	r7, sp, #8
 3486              	.LCFI40:
 3487              		.cfi_def_cfa 7, 32
 3488 0006 F860     		str	r0, [r7, #12]
 3489 0008 B960     		str	r1, [r7, #8]
 3490 000a 3B60     		str	r3, [r7]
 3491 000c BB1D     		adds	r3, r7, #6
 3492 000e 1A80     		strh	r2, [r3]
1422:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint16_t* tmp;
1423:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   uint32_t tickstart = 0U;
 3493              		.loc 1 1423 12
 3494 0010 0023     		movs	r3, #0
 3495 0012 7B61     		str	r3, [r7, #20]
1424:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1425:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   /* Check that a Tx process is not already ongoing */
1426:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   if(huart->gState == HAL_UART_STATE_READY)
 3496              		.loc 1 1426 11
 3497 0014 FB68     		ldr	r3, [r7, #12]
 3498 0016 6922     		movs	r2, #105
 3499 0018 9B5C     		ldrb	r3, [r3, r2]
 3500 001a DBB2     		uxtb	r3, r3
 3501              		.loc 1 1426 5
 3502 001c 202B     		cmp	r3, #32
 3503 001e 00D0     		beq	.LCB3023
 3504 0020 8CE0     		b	.L195	@long jump
 3505              	.LCB3023:
1427:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1428:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if((pData == NULL ) || (Size == 0U))
 3506              		.loc 1 1428 7
 3507 0022 BB68     		ldr	r3, [r7, #8]
 3508 0024 002B     		cmp	r3, #0
 3509 0026 03D0     		beq	.L196
 3510              		.loc 1 1428 25 discriminator 1
 3511 0028 BB1D     		adds	r3, r7, #6
 3512 002a 1B88     		ldrh	r3, [r3]
 3513 002c 002B     		cmp	r3, #0
 3514 002e 01D1     		bne	.L197
 3515              	.L196:
1429:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1430:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return  HAL_ERROR;
 3516              		.loc 1 1430 15
 3517 0030 0123     		movs	r3, #1
 3518 0032 84E0     		b	.L198
 3519              	.L197:
1431:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1432:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1433:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* In case of 9bits/No Parity transfer, pData buffer provided as input paramter 
1434:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        should be aligned on a u16 frontier, as data to be filled into TDR will be 
1435:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****        handled through a u16 cast. */
1436:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 3520              		.loc 1 1436 21
 3521 0034 FB68     		ldr	r3, [r7, #12]
 3522 0036 9A68     		ldr	r2, [r3, #8]
 3523              		.loc 1 1436 8
 3524 0038 8023     		movs	r3, #128
 3525 003a 5B01     		lsls	r3, r3, #5
 3526 003c 9A42     		cmp	r2, r3
 3527 003e 09D1     		bne	.L199
 3528              		.loc 1 1436 71 discriminator 1
 3529 0040 FB68     		ldr	r3, [r7, #12]
 3530 0042 1B69     		ldr	r3, [r3, #16]
 3531              		.loc 1 1436 56 discriminator 1
 3532 0044 002B     		cmp	r3, #0
 3533 0046 05D1     		bne	.L199
1437:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1438:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if((((uint32_t)pData)&1U) != 0U)
 3534              		.loc 1 1438 12
 3535 0048 BB68     		ldr	r3, [r7, #8]
 3536              		.loc 1 1438 28
 3537 004a 0122     		movs	r2, #1
 3538 004c 1340     		ands	r3, r2
 3539              		.loc 1 1438 9
 3540 004e 01D0     		beq	.L199
1439:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1440:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return  HAL_ERROR;
 3541              		.loc 1 1440 17
 3542 0050 0123     		movs	r3, #1
 3543 0052 74E0     		b	.L198
 3544              	.L199:
1441:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1442:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1443:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1444:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Locked */
1445:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_LOCK(huart);
 3545              		.loc 1 1445 5
 3546 0054 FB68     		ldr	r3, [r7, #12]
 3547 0056 6822     		movs	r2, #104
 3548 0058 9B5C     		ldrb	r3, [r3, r2]
 3549 005a 012B     		cmp	r3, #1
 3550 005c 01D1     		bne	.L200
 3551              		.loc 1 1445 5 is_stmt 0 discriminator 1
 3552 005e 0223     		movs	r3, #2
 3553 0060 6DE0     		b	.L198
 3554              	.L200:
 3555              		.loc 1 1445 5 discriminator 2
 3556 0062 FB68     		ldr	r3, [r7, #12]
 3557 0064 6822     		movs	r2, #104
 3558 0066 0121     		movs	r1, #1
 3559 0068 9954     		strb	r1, [r3, r2]
1446:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1447:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->ErrorCode = HAL_UART_ERROR_NONE;
 3560              		.loc 1 1447 22 is_stmt 1 discriminator 2
 3561 006a FB68     		ldr	r3, [r7, #12]
 3562 006c 0022     		movs	r2, #0
 3563 006e DA66     		str	r2, [r3, #108]
1448:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->gState = HAL_UART_STATE_BUSY_TX;
 3564              		.loc 1 1448 19 discriminator 2
 3565 0070 FB68     		ldr	r3, [r7, #12]
 3566 0072 6922     		movs	r2, #105
 3567 0074 2121     		movs	r1, #33
 3568 0076 9954     		strb	r1, [r3, r2]
1449:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1450:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Init tickstart for timeout managment*/
1451:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     tickstart = HAL_GetTick();
 3569              		.loc 1 1451 17 discriminator 2
 3570 0078 FFF7FEFF 		bl	HAL_GetTick
 3571 007c 0300     		movs	r3, r0
 3572 007e 7B61     		str	r3, [r7, #20]
1452:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1453:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->TxXferSize = Size;
 3573              		.loc 1 1453 23 discriminator 2
 3574 0080 FB68     		ldr	r3, [r7, #12]
 3575 0082 BA1D     		adds	r2, r7, #6
 3576 0084 5021     		movs	r1, #80
 3577 0086 1288     		ldrh	r2, [r2]
 3578 0088 5A52     		strh	r2, [r3, r1]
1454:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->TxXferCount = Size;
 3579              		.loc 1 1454 24 discriminator 2
 3580 008a FB68     		ldr	r3, [r7, #12]
 3581 008c BA1D     		adds	r2, r7, #6
 3582 008e 5221     		movs	r1, #82
 3583 0090 1288     		ldrh	r2, [r2]
 3584 0092 5A52     		strh	r2, [r3, r1]
1455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     while(huart->TxXferCount > 0)
 3585              		.loc 1 1455 10 discriminator 2
 3586 0094 35E0     		b	.L201
 3587              	.L204:
1456:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1457:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       huart->TxXferCount--;
 3588              		.loc 1 1457 12
 3589 0096 FB68     		ldr	r3, [r7, #12]
 3590 0098 5222     		movs	r2, #82
 3591 009a 9B5A     		ldrh	r3, [r3, r2]
 3592 009c 9BB2     		uxth	r3, r3
 3593              		.loc 1 1457 25
 3594 009e 013B     		subs	r3, r3, #1
 3595 00a0 99B2     		uxth	r1, r3
 3596 00a2 FB68     		ldr	r3, [r7, #12]
 3597 00a4 5222     		movs	r2, #82
 3598 00a6 9952     		strh	r1, [r3, r2]
1458:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 3599              		.loc 1 1458 10
 3600 00a8 7A69     		ldr	r2, [r7, #20]
 3601 00aa F868     		ldr	r0, [r7, #12]
 3602 00ac 3B68     		ldr	r3, [r7]
 3603 00ae 0093     		str	r3, [sp]
 3604 00b0 1300     		movs	r3, r2
 3605 00b2 0022     		movs	r2, #0
 3606 00b4 8021     		movs	r1, #128
 3607 00b6 FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3608 00ba 031E     		subs	r3, r0, #0
 3609              		.loc 1 1458 9
 3610 00bc 01D0     		beq	.L202
1459:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1460:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         return HAL_TIMEOUT;
 3611              		.loc 1 1460 16
 3612 00be 0323     		movs	r3, #3
 3613 00c0 3DE0     		b	.L198
 3614              	.L202:
1461:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1462:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE
 3615              		.loc 1 1462 23
 3616 00c2 FB68     		ldr	r3, [r7, #12]
 3617 00c4 9A68     		ldr	r2, [r3, #8]
 3618              		.loc 1 1462 10
 3619 00c6 8023     		movs	r3, #128
 3620 00c8 5B01     		lsls	r3, r3, #5
 3621 00ca 9A42     		cmp	r2, r3
 3622 00cc 11D1     		bne	.L203
 3623              		.loc 1 1462 73 discriminator 1
 3624 00ce FB68     		ldr	r3, [r7, #12]
 3625 00d0 1B69     		ldr	r3, [r3, #16]
 3626              		.loc 1 1462 58 discriminator 1
 3627 00d2 002B     		cmp	r3, #0
 3628 00d4 0DD1     		bne	.L203
1463:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1464:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         tmp = (uint16_t*) pData;
 3629              		.loc 1 1464 13
 3630 00d6 BB68     		ldr	r3, [r7, #8]
 3631 00d8 3B61     		str	r3, [r7, #16]
1465:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 3632              		.loc 1 1465 33
 3633 00da 3B69     		ldr	r3, [r7, #16]
 3634 00dc 1A88     		ldrh	r2, [r3]
 3635              		.loc 1 1465 14
 3636 00de FB68     		ldr	r3, [r7, #12]
 3637 00e0 1B68     		ldr	r3, [r3]
 3638              		.loc 1 1465 38
 3639 00e2 D205     		lsls	r2, r2, #23
 3640 00e4 D20D     		lsrs	r2, r2, #23
 3641 00e6 92B2     		uxth	r2, r2
 3642              		.loc 1 1465 30
 3643 00e8 1A85     		strh	r2, [r3, #40]
1466:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         pData += 2;
 3644              		.loc 1 1466 15
 3645 00ea BB68     		ldr	r3, [r7, #8]
 3646 00ec 0233     		adds	r3, r3, #2
 3647 00ee BB60     		str	r3, [r7, #8]
 3648 00f0 07E0     		b	.L201
 3649              	.L203:
1467:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1468:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       else
1469:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       {
1470:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****         huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 3650              		.loc 1 1470 39
 3651 00f2 BB68     		ldr	r3, [r7, #8]
 3652 00f4 5A1C     		adds	r2, r3, #1
 3653 00f6 BA60     		str	r2, [r7, #8]
 3654              		.loc 1 1470 33
 3655 00f8 1A78     		ldrb	r2, [r3]
 3656              		.loc 1 1470 14
 3657 00fa FB68     		ldr	r3, [r7, #12]
 3658 00fc 1B68     		ldr	r3, [r3]
 3659              		.loc 1 1470 33
 3660 00fe 92B2     		uxth	r2, r2
 3661              		.loc 1 1470 30
 3662 0100 1A85     		strh	r2, [r3, #40]
 3663              	.L201:
1455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3664              		.loc 1 1455 16
 3665 0102 FB68     		ldr	r3, [r7, #12]
 3666 0104 5222     		movs	r2, #82
 3667 0106 9B5A     		ldrh	r3, [r3, r2]
 3668 0108 9BB2     		uxth	r3, r3
1455:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
 3669              		.loc 1 1455 30
 3670 010a 002B     		cmp	r3, #0
 3671 010c C3D1     		bne	.L204
1471:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       }
1472:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1473:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     if(UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 3672              		.loc 1 1473 8
 3673 010e 7A69     		ldr	r2, [r7, #20]
 3674 0110 F868     		ldr	r0, [r7, #12]
 3675 0112 3B68     		ldr	r3, [r7]
 3676 0114 0093     		str	r3, [sp]
 3677 0116 1300     		movs	r3, r2
 3678 0118 0022     		movs	r2, #0
 3679 011a 4021     		movs	r1, #64
 3680 011c FFF7FEFF 		bl	UART_WaitOnFlagUntilTimeout
 3681 0120 031E     		subs	r3, r0, #0
 3682              		.loc 1 1473 7
 3683 0122 01D0     		beq	.L205
1474:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     {
1475:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****       return HAL_TIMEOUT;
 3684              		.loc 1 1475 14
 3685 0124 0323     		movs	r3, #3
 3686 0126 0AE0     		b	.L198
 3687              	.L205:
1476:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     }
1477:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1478:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* At end of Tx process, restore huart->gState to Ready */
1479:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     huart->gState = HAL_UART_STATE_READY;
 3688              		.loc 1 1479 19
 3689 0128 FB68     		ldr	r3, [r7, #12]
 3690 012a 6922     		movs	r2, #105
 3691 012c 2021     		movs	r1, #32
 3692 012e 9954     		strb	r1, [r3, r2]
1480:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1481:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     /* Process Unlocked */
1482:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     __HAL_UNLOCK(huart);
 3693              		.loc 1 1482 5
 3694 0130 FB68     		ldr	r3, [r7, #12]
 3695 0132 6822     		movs	r2, #104
 3696 0134 0021     		movs	r1, #0
 3697 0136 9954     		strb	r1, [r3, r2]
1483:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** 
1484:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_OK;
 3698              		.loc 1 1484 12
 3699 0138 0023     		movs	r3, #0
 3700 013a 00E0     		b	.L198
 3701              	.L195:
1485:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1486:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   else
1487:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   {
1488:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****     return HAL_BUSY;
 3702              		.loc 1 1488 12
 3703 013c 0223     		movs	r3, #2
 3704              	.L198:
1489:.././hal/stm32f0/stm32f0_hal_lowlevel.c ****   }
1490:.././hal/stm32f0/stm32f0_hal_lowlevel.c **** }
 3705              		.loc 1 1490 1
 3706 013e 1800     		movs	r0, r3
 3707 0140 BD46     		mov	sp, r7
 3708 0142 06B0     		add	sp, sp, #24
 3709              		@ sp needed
 3710 0144 80BD     		pop	{r7, pc}
 3711              		.cfi_endproc
 3712              	.LFE51:
 3714              		.bss
 3715              		.align	2
 3716              	tick.0:
 3717 0000 00000000 		.space	4
 3719              		.text
 3720              	.Letext0:
 3721              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 3722              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 3723              		.file 4 ".././hal/stm32f0/CMSIS/device/stm32f030x6.h"
 3724              		.file 5 ".././hal/stm32f0/CMSIS/device/stm32f0xx.h"
 3725              		.file 6 ".././hal/stm32f0/stm32f0xx_hal_def.h"
 3726              		.file 7 ".././hal/stm32f0/stm32f0xx_hal_rcc.h"
 3727              		.file 8 ".././hal/stm32f0/stm32f0xx_hal_rcc_ex.h"
 3728              		.file 9 ".././hal/stm32f0/stm32f0xx_hal_gpio.h"
 3729              		.file 10 ".././hal/stm32f0/stm32f0xx_hal_dma.h"
 3730              		.file 11 ".././hal/stm32f0/stm32f0xx_hal_uart.h"
 3731              		.file 12 ".././hal/stm32f0/CMSIS/device/system_stm32f0xx.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f0_hal_lowlevel.c
     /tmp/ccpmbgxC.s:16     .text.HAL_GetTick:0000000000000000 $t
     /tmp/ccpmbgxC.s:24     .text.HAL_GetTick:0000000000000000 HAL_GetTick
     /tmp/ccpmbgxC.s:54     .text.HAL_GetTick:0000000000000018 $d
     /tmp/ccpmbgxC.s:3716   .bss:0000000000000000 tick.0
     /tmp/ccpmbgxC.s:63     .data:0000000000000000 SystemCoreClock
     /tmp/ccpmbgxC.s:60     .data:0000000000000000 $d
     /tmp/ccpmbgxC.s:66     .text.HAL_RCC_GetSysClockFreq:0000000000000000 $t
     /tmp/ccpmbgxC.s:73     .text.HAL_RCC_GetSysClockFreq:0000000000000000 HAL_RCC_GetSysClockFreq
     /tmp/ccpmbgxC.s:99     .text.HAL_RCC_GetPCLK1Freq:0000000000000000 $t
     /tmp/ccpmbgxC.s:106    .text.HAL_RCC_GetPCLK1Freq:0000000000000000 HAL_RCC_GetPCLK1Freq
     /tmp/ccpmbgxC.s:132    .text.HAL_RCC_GetPCLK2Freq:0000000000000000 $t
     /tmp/ccpmbgxC.s:139    .text.HAL_RCC_GetPCLK2Freq:0000000000000000 HAL_RCC_GetPCLK2Freq
     /tmp/ccpmbgxC.s:165    .text.HAL_RCC_OscConfig:0000000000000000 $t
     /tmp/ccpmbgxC.s:172    .text.HAL_RCC_OscConfig:0000000000000000 HAL_RCC_OscConfig
     /tmp/ccpmbgxC.s:739    .text.HAL_RCC_OscConfig:0000000000000328 $d
     /tmp/ccpmbgxC.s:745    .text.HAL_RCC_OscConfig:0000000000000338 $t
     /tmp/ccpmbgxC.s:1190   .text.HAL_RCC_OscConfig:00000000000005d4 $d
     /tmp/ccpmbgxC.s:1199   .text.HAL_RCC_ClockConfig:0000000000000000 $t
     /tmp/ccpmbgxC.s:1206   .text.HAL_RCC_ClockConfig:0000000000000000 HAL_RCC_ClockConfig
     /tmp/ccpmbgxC.s:1513   .text.HAL_RCC_ClockConfig:000000000000019c $d
     /tmp/ccpmbgxC.s:1522   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000000 $t
     /tmp/ccpmbgxC.s:1529   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000000 HAL_RCCEx_PeriphCLKConfig
     /tmp/ccpmbgxC.s:1807   .text.HAL_RCCEx_PeriphCLKConfig:0000000000000184 $d
     /tmp/ccpmbgxC.s:1817   .text.HAL_GPIO_Init:0000000000000000 $t
     /tmp/ccpmbgxC.s:1824   .text.HAL_GPIO_Init:0000000000000000 HAL_GPIO_Init
     /tmp/ccpmbgxC.s:2327   .text.HAL_GPIO_Init:00000000000002d0 $d
     /tmp/ccpmbgxC.s:2337   .text.HAL_GPIO_WritePin:0000000000000000 $t
     /tmp/ccpmbgxC.s:2344   .text.HAL_GPIO_WritePin:0000000000000000 HAL_GPIO_WritePin
     /tmp/ccpmbgxC.s:2401   .text.UART_WaitOnFlagUntilTimeout:0000000000000000 $t
     /tmp/ccpmbgxC.s:2408   .text.UART_WaitOnFlagUntilTimeout:0000000000000000 UART_WaitOnFlagUntilTimeout
     /tmp/ccpmbgxC.s:2519   .text.UART_WaitOnFlagUntilTimeout:0000000000000094 $d
     /tmp/ccpmbgxC.s:2524   .text.UART_CheckIdleState:0000000000000000 $t
     /tmp/ccpmbgxC.s:2531   .text.UART_CheckIdleState:0000000000000000 UART_CheckIdleState
     /tmp/ccpmbgxC.s:2581   .text.UART_SetConfig:0000000000000000 $t
     /tmp/ccpmbgxC.s:2588   .text.UART_SetConfig:0000000000000000 UART_SetConfig
     /tmp/ccpmbgxC.s:3027   .text.UART_SetConfig:00000000000002a8 $d
     /tmp/ccpmbgxC.s:3037   .text.HAL_UART_Init:0000000000000000 $t
     /tmp/ccpmbgxC.s:3044   .text.HAL_UART_Init:0000000000000000 HAL_UART_Init
     /tmp/ccpmbgxC.s:3152   .text.HAL_UART_Init:0000000000000094 $d
     /tmp/ccpmbgxC.s:3157   .text.HAL_UART_Receive:0000000000000000 $t
     /tmp/ccpmbgxC.s:3164   .text.HAL_UART_Receive:0000000000000000 HAL_UART_Receive
     /tmp/ccpmbgxC.s:3459   .text.HAL_UART_Receive:0000000000000198 $d
     /tmp/ccpmbgxC.s:3464   .text.HAL_UART_Transmit:0000000000000000 $t
     /tmp/ccpmbgxC.s:3471   .text.HAL_UART_Transmit:0000000000000000 HAL_UART_Transmit
     /tmp/ccpmbgxC.s:3715   .bss:0000000000000000 $d

UNDEFINED SYMBOLS
__aeabi_uidiv
